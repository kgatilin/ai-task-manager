
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kgatilin/darwinflow-pub/internal/app/analysis.go (66.4%)</option>
				
				<option value="file1">github.com/kgatilin/darwinflow-pub/internal/app/analysis_prompt.go (100.0%)</option>
				
				<option value="file2">github.com/kgatilin/darwinflow-pub/internal/app/analyze_cmd.go (66.1%)</option>
				
				<option value="file3">github.com/kgatilin/darwinflow-pub/internal/app/command_registry.go (82.1%)</option>
				
				<option value="file4">github.com/kgatilin/darwinflow-pub/internal/app/config_handler.go (94.4%)</option>
				
				<option value="file5">github.com/kgatilin/darwinflow-pub/internal/app/event_dispatcher.go (73.9%)</option>
				
				<option value="file6">github.com/kgatilin/darwinflow-pub/internal/app/logger.go (95.7%)</option>
				
				<option value="file7">github.com/kgatilin/darwinflow-pub/internal/app/logs.go (86.6%)</option>
				
				<option value="file8">github.com/kgatilin/darwinflow-pub/internal/app/logs_cmd.go (95.1%)</option>
				
				<option value="file9">github.com/kgatilin/darwinflow-pub/internal/app/plugin_context.go (100.0%)</option>
				
				<option value="file10">github.com/kgatilin/darwinflow-pub/internal/app/plugin_registry.go (91.7%)</option>
				
				<option value="file11">github.com/kgatilin/darwinflow-pub/internal/app/refresh_cmd.go (96.3%)</option>
				
				<option value="file12">github.com/kgatilin/darwinflow-pub/internal/app/setup.go (87.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "text/template"
        "time"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
        "github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// NoOpLogger is a logger that does nothing (for backward compatibility)
type NoOpLogger struct{}

func (l *NoOpLogger) Debug(format string, args ...interface{}) {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) Info(format string, args ...interface{})  {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) Warn(format string, args ...interface{})  {<span class="cov8" title="1">}</span>
func (l *NoOpLogger) Error(format string, args ...interface{}) {<span class="cov8" title="1">}</span>

// Deprecated: Use domain.LLM instead
// LLMExecutor is kept for backward compatibility
type LLMExecutor interface {
        // Execute runs an LLM query with the given prompt and returns the response
        Execute(ctx context.Context, prompt string) (string, error)
}

// Logger interface for dependency injection
type Logger interface {
        Debug(format string, args ...interface{})
        Info(format string, args ...interface{})
        Warn(format string, args ...interface{})
        Error(format string, args ...interface{})
}

// SessionViewFactory is a function type that creates a view from a session ID and events
// This allows the service to work with views without importing plugin packages directly
type SessionViewFactory func(sessionID string, events []pluginsdk.Event) pluginsdk.AnalysisView

// AnalysisService handles session analysis operations
type AnalysisService struct {
        eventRepo         domain.EventRepository
        analysisRepo      domain.AnalysisRepository
        logsService       *LogsService
        llm               domain.LLM
        logger            Logger
        config            *domain.Config
        sessionViewFactory SessionViewFactory // Injected factory for creating session views
}

// NewAnalysisService creates a new analysis service
func NewAnalysisService(
        eventRepo domain.EventRepository,
        analysisRepo domain.AnalysisRepository,
        logsService *LogsService,
        llm domain.LLM,
        logger Logger,
        config *domain.Config,
) *AnalysisService <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = domain.DefaultConfig()
        }</span>
        <span class="cov8" title="1">return &amp;AnalysisService{
                eventRepo:          eventRepo,
                analysisRepo:       analysisRepo,
                logsService:        logsService,
                llm:                llm,
                logger:             logger,
                config:             config,
                sessionViewFactory: nil, // Can be set via SetSessionViewFactory
        }</span>
}

// SetSessionViewFactory sets the factory function for creating session views
// This is typically called during initialization to wire up the plugin
func (s *AnalysisService) SetSessionViewFactory(factory SessionViewFactory) <span class="cov8" title="1">{
        s.sessionViewFactory = factory
}</span>

// AnalyzeSession analyzes a specific session with the default analysis prompt
// This is kept for backward compatibility - uses "tool_analysis" prompt
func (s *AnalysisService) AnalyzeSession(ctx context.Context, sessionID string) (*domain.SessionAnalysis, error) <span class="cov8" title="1">{
        return s.AnalyzeSessionWithPrompt(ctx, sessionID, "tool_analysis")
}</span>

// AnalyzeSessionWithPrompt analyzes a specific session with a named prompt from config
// This is now a wrapper around the view-based AnalyzeView method for backward compatibility
func (s *AnalysisService) AnalyzeSessionWithPrompt(ctx context.Context, sessionID, promptName string) (*domain.SessionAnalysis, error) <span class="cov8" title="1">{
        // Get session events using FindByQuery
        s.logger.Debug("Fetching events for session %s", sessionID)
        query := pluginsdk.EventQuery{
                Metadata: map[string]string{
                        "session_id": sessionID,
                },
        }
        events, err := s.eventRepo.FindByQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to get session events: %v", err)
                return nil, fmt.Errorf("failed to get session events: %w", err)
        }</span>

        <span class="cov8" title="1">if len(events) == 0 </span><span class="cov8" title="1">{
                s.logger.Warn("No events found for session %s", sessionID)
                return nil, fmt.Errorf("no events found for session %s", sessionID)
        }</span>
        <span class="cov8" title="1">s.logger.Debug("Found %d events for session %s", len(events), sessionID)

        // Convert domain.Event to pluginsdk.Event
        pluginEvents := make([]pluginsdk.Event, len(events))
        for i, e := range events </span><span class="cov8" title="1">{
                // Convert payload to map if needed
                payloadMap := make(map[string]interface{})
                if e.Payload != nil </span><span class="cov8" title="1">{
                        if m, ok := e.Payload.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                payloadMap = m
                        }</span> else<span class="cov0" title="0"> {
                                // Try to marshal and unmarshal to get a map
                                jsonBytes, _ := e.MarshalPayload()
                                _ = json.Unmarshal(jsonBytes, &amp;payloadMap)
                        }</span>
                }

                // Create metadata map with session_id
                <span class="cov8" title="1">metadata := map[string]string{
                        "session_id": e.SessionID,
                }

                pluginEvents[i] = pluginsdk.Event{
                        Type:      e.Type,
                        Source:    "claude_code",
                        Timestamp: e.Timestamp,
                        Payload:   payloadMap,
                        Metadata:  metadata,
                        Version:   e.Version,
                }</span>
        }

        // Create SessionView from events using the injected factory
        <span class="cov8" title="1">var sessionView pluginsdk.AnalysisView
        if s.sessionViewFactory != nil </span><span class="cov8" title="1">{
                sessionView = s.sessionViewFactory(sessionID, pluginEvents)
        }</span> else<span class="cov0" title="0"> {
                // Fallback if factory not set (should not happen in normal operation)
                return nil, fmt.Errorf("session view factory not configured")
        }</span>

        // Call the view-based analysis method
        <span class="cov8" title="1">analysis, err := s.AnalyzeView(ctx, sessionView, promptName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get the prompt template from config for backward compatibility
        <span class="cov8" title="1">promptTemplate, exists := s.config.Prompts[promptName]
        if !exists || promptTemplate == "" </span><span class="cov8" title="1">{
                promptTemplate = domain.DefaultToolAnalysisPrompt
        }</span>

        // Convert generic Analysis to SessionAnalysis for backward compatibility
        <span class="cov8" title="1">sessionAnalysis := domain.NewSessionAnalysisWithType(
                sessionID,
                analysis.Result,
                analysis.ModelUsed,
                promptTemplate,
                analysis.PromptUsed,
                analysis.PromptUsed,
        )

        // Preserve the created timestamp from generic analysis
        sessionAnalysis.AnalyzedAt = analysis.Timestamp

        // Save the SessionAnalysis for backward compatibility
        // (The generic Analysis was already saved by AnalyzeView)
        if err := s.analysisRepo.SaveAnalysis(ctx, sessionAnalysis); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save session analysis: %v", err)
                return nil, fmt.Errorf("failed to save session analysis: %w", err)
        }</span>

        <span class="cov8" title="1">return sessionAnalysis, nil</span>
}

// AnalyzeView analyzes any view using the provided prompt.
// This method provides a view-based interface for analysis that's plugin-agnostic.
// Returns a generic Analysis type that works with any view from any plugin.
func (s *AnalysisService) AnalyzeView(ctx context.Context, view pluginsdk.AnalysisView, promptName string) (*domain.Analysis, error) <span class="cov8" title="1">{
        if view == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("view is nil")
        }</span>

        // Get the formatted view content
        <span class="cov8" title="1">s.logger.Debug("Formatting view %s (%s) for analysis", view.GetID(), view.GetType())
        formattedContent := view.FormatForAnalysis()

        // Get analysis prompt from config
        promptTemplate, exists := s.config.Prompts[promptName]
        if !exists || promptTemplate == "" </span><span class="cov8" title="1">{
                s.logger.Warn("Prompt %s not found in config, using default tool_analysis", promptName)
                promptTemplate = domain.DefaultToolAnalysisPrompt
                promptName = "tool_analysis"
        }</span>

        // Build the full prompt with formatted view
        <span class="cov8" title="1">prompt := promptTemplate + formattedContent
        s.logger.Debug("Generated prompt with %d characters (%d KB)", len(prompt), len(prompt)/1024)

        // Execute LLM analysis
        s.logger.Info("Invoking LLM for %s analysis of view %s...", promptName, view.GetID())
        analysisResult, err := s.llm.Query(ctx, prompt, nil)
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error("Failed to execute LLM analysis: %v", err)
                return nil, fmt.Errorf("failed to execute LLM analysis: %w", err)
        }</span>
        <span class="cov8" title="1">s.logger.Debug("LLM returned %d characters", len(analysisResult))

        // Create generic analysis
        s.logger.Debug("Saving analysis to database")
        analysis := domain.NewAnalysis(
                view.GetID(),
                view.GetType(),
                analysisResult,
                s.config.Analysis.Model,
                promptName,
        )

        // Add view metadata if available
        if metadata := view.GetMetadata(); metadata != nil </span><span class="cov8" title="1">{
                analysis.Metadata = metadata
        }</span>

        // Save to database using generic method
        <span class="cov8" title="1">if err := s.analysisRepo.SaveGenericAnalysis(ctx, analysis); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save analysis: %v", err)
                return nil, fmt.Errorf("failed to save analysis: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("View analysis completed successfully")
        return analysis, nil</span>
}

// AnalysisOptions contains options for view-based analysis
type AnalysisOptions struct {
        // Model override (empty uses config default)
        ModelOverride string
        // Custom LLM options (e.g., temperature, max_tokens)
        LLMOptions *domain.LLMOptions
}

// AnalyzeViewWithOptions analyzes a view with custom options
// This allows more flexible control over analysis parameters
func (s *AnalysisService) AnalyzeViewWithOptions(ctx context.Context, view pluginsdk.AnalysisView, promptName string, options *AnalysisOptions) (*domain.Analysis, error) <span class="cov0" title="0">{
        if view == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("view is nil")
        }</span>

        <span class="cov0" title="0">if options == nil </span><span class="cov0" title="0">{
                options = &amp;AnalysisOptions{}
        }</span>

        // Get the formatted view content
        <span class="cov0" title="0">s.logger.Debug("Formatting view %s (%s) for analysis", view.GetID(), view.GetType())
        formattedContent := view.FormatForAnalysis()

        // Get analysis prompt from config
        promptTemplate, exists := s.config.Prompts[promptName]
        if !exists || promptTemplate == "" </span><span class="cov0" title="0">{
                s.logger.Warn("Prompt %s not found in config, using default tool_analysis", promptName)
                promptTemplate = domain.DefaultToolAnalysisPrompt
                promptName = "tool_analysis"
        }</span>

        // Build the full prompt with formatted view
        <span class="cov0" title="0">prompt := promptTemplate + formattedContent
        s.logger.Debug("Generated prompt with %d characters (%d KB)", len(prompt), len(prompt)/1024)

        // Determine model to use
        model := s.config.Analysis.Model
        if options.ModelOverride != "" </span><span class="cov0" title="0">{
                model = options.ModelOverride
        }</span>

        // Execute LLM analysis with options
        <span class="cov0" title="0">s.logger.Info("Invoking LLM for %s analysis of view %s...", promptName, view.GetID())
        analysisResult, err := s.llm.Query(ctx, prompt, options.LLMOptions)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to execute LLM analysis: %v", err)
                return nil, fmt.Errorf("failed to execute LLM analysis: %w", err)
        }</span>
        <span class="cov0" title="0">s.logger.Debug("LLM returned %d characters", len(analysisResult))

        // Create generic analysis
        s.logger.Debug("Saving analysis to database")
        analysis := domain.NewAnalysis(
                view.GetID(),
                view.GetType(),
                analysisResult,
                model,
                promptName,
        )

        // Add view metadata if available
        if metadata := view.GetMetadata(); metadata != nil </span><span class="cov0" title="0">{
                analysis.Metadata = metadata
        }</span>

        // Save to database using generic method
        <span class="cov0" title="0">if err := s.analysisRepo.SaveGenericAnalysis(ctx, analysis); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("Failed to save analysis: %v", err)
                return nil, fmt.Errorf("failed to save analysis: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("View analysis with options completed successfully")
        return analysis, nil</span>
}

// AnalyzeMultipleSessions analyzes multiple sessions with a specific prompt
// Returns a map of sessionID -&gt; analysis, and any errors encountered
func (s *AnalysisService) AnalyzeMultipleSessions(ctx context.Context, sessionIDs []string, promptName string) (map[string]*domain.SessionAnalysis, []error) <span class="cov8" title="1">{
        results := make(map[string]*domain.SessionAnalysis)
        var errors []error

        for _, sessionID := range sessionIDs </span><span class="cov8" title="1">{
                analysis, err := s.AnalyzeSessionWithPrompt(ctx, sessionID, promptName)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("session %s: %w", sessionID, err))
                        continue</span>
                }
                <span class="cov8" title="1">results[sessionID] = analysis</span>
        }

        <span class="cov8" title="1">return results, errors</span>
}

// AnalysisResult represents the result of a parallel analysis
type AnalysisResult struct {
        SessionID  string
        PromptName string
        Analysis   *domain.SessionAnalysis
        Error      error
}

// AnalyzeMultipleSessionsParallel analyzes multiple sessions in parallel
// Uses a semaphore to limit concurrent executions based on config.Analysis.ParallelLimit
func (s *AnalysisService) AnalyzeMultipleSessionsParallel(ctx context.Context, sessionIDs []string, promptName string) (map[string]*domain.SessionAnalysis, []error) <span class="cov8" title="1">{
        if len(sessionIDs) == 0 </span><span class="cov8" title="1">{
                return make(map[string]*domain.SessionAnalysis), nil
        }</span>

        <span class="cov8" title="1">parallelLimit := s.config.Analysis.ParallelLimit
        if parallelLimit &lt;= 0 </span><span class="cov0" title="0">{
                parallelLimit = 1
        }</span>

        <span class="cov8" title="1">s.logger.Info("Starting parallel analysis of %d sessions (max parallel: %d)", len(sessionIDs), parallelLimit)

        // Semaphore to limit concurrent executions
        sem := make(chan struct{}, parallelLimit)
        resultsChan := make(chan AnalysisResult, len(sessionIDs))
        var wg sync.WaitGroup

        // Launch goroutines
        for _, sessionID := range sessionIDs </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(sid string) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        // Acquire semaphore
                        sem &lt;- struct{}{}
                        defer func() </span><span class="cov8" title="1">{ &lt;-sem }</span>()

                        <span class="cov8" title="1">s.logger.Debug("Analyzing session %s in parallel", sid)
                        analysis, err := s.AnalyzeSessionWithPrompt(ctx, sid, promptName)

                        resultsChan &lt;- AnalysisResult{
                                SessionID:  sid,
                                PromptName: promptName,
                                Analysis:   analysis,
                                Error:      err,
                        }</span>
                }(sessionID)
        }

        // Wait for all goroutines to complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultsChan)
        }</span>()

        // Collect results
        <span class="cov8" title="1">results := make(map[string]*domain.SessionAnalysis)
        var errors []error

        for result := range resultsChan </span><span class="cov8" title="1">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("session %s: %w", result.SessionID, result.Error))
                        s.logger.Warn("Parallel analysis failed for session %s: %v", result.SessionID, result.Error)
                }</span> else<span class="cov8" title="1"> {
                        results[result.SessionID] = result.Analysis
                        s.logger.Debug("Parallel analysis completed for session %s", result.SessionID)
                }</span>
        }

        <span class="cov8" title="1">s.logger.Info("Parallel analysis complete: %d/%d successful", len(results), len(sessionIDs))
        return results, errors</span>
}

// AnalyzeSessionWithMultiplePrompts analyzes a single session with multiple prompts in parallel
func (s *AnalysisService) AnalyzeSessionWithMultiplePrompts(ctx context.Context, sessionID string, promptNames []string) (map[string]*domain.SessionAnalysis, []error) <span class="cov8" title="1">{
        if len(promptNames) == 0 </span><span class="cov8" title="1">{
                return make(map[string]*domain.SessionAnalysis), nil
        }</span>

        <span class="cov8" title="1">parallelLimit := s.config.Analysis.ParallelLimit
        if parallelLimit &lt;= 0 </span><span class="cov0" title="0">{
                parallelLimit = 1
        }</span>

        <span class="cov8" title="1">s.logger.Info("Analyzing session %s with %d prompts in parallel", sessionID, len(promptNames))

        // Semaphore to limit concurrent executions
        sem := make(chan struct{}, parallelLimit)
        resultsChan := make(chan AnalysisResult, len(promptNames))
        var wg sync.WaitGroup

        // Launch goroutines
        for _, promptName := range promptNames </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(pname string) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        // Acquire semaphore
                        sem &lt;- struct{}{}
                        defer func() </span><span class="cov8" title="1">{ &lt;-sem }</span>()

                        <span class="cov8" title="1">s.logger.Debug("Analyzing session %s with prompt %s", sessionID, pname)
                        analysis, err := s.AnalyzeSessionWithPrompt(ctx, sessionID, pname)

                        resultsChan &lt;- AnalysisResult{
                                SessionID:  sessionID,
                                PromptName: pname,
                                Analysis:   analysis,
                                Error:      err,
                        }</span>
                }(promptName)
        }

        // Wait for all goroutines to complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultsChan)
        }</span>()

        // Collect results
        <span class="cov8" title="1">results := make(map[string]*domain.SessionAnalysis)
        var errors []error

        for result := range resultsChan </span><span class="cov8" title="1">{
                if result.Error != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("prompt %s: %w", result.PromptName, result.Error))
                        s.logger.Warn("Analysis failed for prompt %s: %v", result.PromptName, result.Error)
                }</span> else<span class="cov8" title="1"> {
                        results[result.PromptName] = result.Analysis
                        s.logger.Debug("Analysis completed for prompt %s", result.PromptName)
                }</span>
        }

        <span class="cov8" title="1">s.logger.Info("Multi-prompt analysis complete: %d/%d successful", len(results), len(promptNames))
        return results, errors</span>
}

// EstimateTokenCount estimates the token count for a session's logs
// Uses a simple chars/4 heuristic (common approximation for Claude models)
func (s *AnalysisService) EstimateTokenCount(ctx context.Context, sessionID string) (int, error) <span class="cov8" title="1">{
        logs, err := s.logsService.ListRecentLogs(ctx, 0, 0, sessionID, true)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get session logs: %w", err)
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        if err := FormatLogsAsMarkdown(&amp;buf, logs); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to format logs: %w", err)
        }</span>

        // Estimate tokens: ~4 characters per token (conservative estimate)
        <span class="cov8" title="1">charCount := buf.Len()
        tokenEstimate := charCount / 4

        s.logger.Debug("Session %s: %d chars â‰ˆ %d tokens", sessionID, charCount, tokenEstimate)
        return tokenEstimate, nil</span>
}

// SelectSessionsWithinTokenLimit selects sessions that fit within the token limit
// Returns selected session IDs and total estimated tokens
func (s *AnalysisService) SelectSessionsWithinTokenLimit(ctx context.Context, sessionIDs []string, tokenLimit int) ([]string, int, error) <span class="cov8" title="1">{
        if tokenLimit &lt;= 0 </span><span class="cov0" title="0">{
                tokenLimit = s.config.Analysis.TokenLimit
        }</span>

        <span class="cov8" title="1">var selected []string
        totalTokens := 0

        // Reserve 20% of tokens for prompt overhead and response
        availableTokens := int(float64(tokenLimit) * 0.8)

        s.logger.Debug("Selecting sessions within %d tokens (%.0f%% of %d limit)", availableTokens, 80.0, tokenLimit)

        for _, sessionID := range sessionIDs </span><span class="cov8" title="1">{
                tokenCount, err := s.EstimateTokenCount(ctx, sessionID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("Failed to estimate tokens for session %s: %v", sessionID, err)
                        continue</span>
                }

                <span class="cov8" title="1">if totalTokens+tokenCount &lt;= availableTokens </span><span class="cov8" title="1">{
                        selected = append(selected, sessionID)
                        totalTokens += tokenCount
                        s.logger.Debug("Selected session %s (%d tokens, total: %d/%d)", sessionID, tokenCount, totalTokens, availableTokens)
                }</span> else<span class="cov0" title="0"> {
                        s.logger.Debug("Skipping session %s (%d tokens would exceed limit: %d + %d &gt; %d)",
                                sessionID, tokenCount, totalTokens, tokenCount, availableTokens)
                        break</span>
                }
        }

        <span class="cov8" title="1">s.logger.Info("Selected %d/%d sessions (%d tokens, %.1f%% of limit)",
                len(selected), len(sessionIDs), totalTokens, float64(totalTokens)/float64(tokenLimit)*100)

        return selected, totalTokens, nil</span>
}

// GetLastSession returns the ID of the most recent session
func (s *AnalysisService) GetLastSession(ctx context.Context) (string, error) <span class="cov8" title="1">{
        logs, err := s.logsService.ListRecentLogs(ctx, 1, 0, "", false)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get last session: %w", err)
        }</span>

        <span class="cov8" title="1">if len(logs) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no sessions found")
        }</span>

        <span class="cov8" title="1">return logs[0].SessionID, nil</span>
}

// GetUnanalyzedSessions returns all session IDs that haven't been analyzed
func (s *AnalysisService) GetUnanalyzedSessions(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        return s.analysisRepo.GetUnanalyzedSessionIDs(ctx)
}</span>

// GetAnalysis retrieves the most recent analysis for a session
func (s *AnalysisService) GetAnalysis(ctx context.Context, sessionID string) (*domain.SessionAnalysis, error) <span class="cov8" title="1">{
        return s.analysisRepo.GetAnalysisBySessionID(ctx, sessionID)
}</span>

// GetAnalysesBySessionID retrieves all analyses for a session
func (s *AnalysisService) GetAnalysesBySessionID(ctx context.Context, sessionID string) ([]*domain.SessionAnalysis, error) <span class="cov8" title="1">{
        return s.analysisRepo.GetAnalysesBySessionID(ctx, sessionID)
}</span>

// GetAnalysesByViewID retrieves all generic analyses for a view ID (e.g., session ID)
func (s *AnalysisService) GetAnalysesByViewID(ctx context.Context, viewID string) ([]*domain.Analysis, error) <span class="cov0" title="0">{
        return s.analysisRepo.FindAnalysisByViewID(ctx, viewID)
}</span>

// GetAllSessionIDs retrieves all session IDs, ordered by most recent first
// If limit &gt; 0, returns only the latest N sessions
func (s *AnalysisService) GetAllSessionIDs(ctx context.Context, limit int) ([]string, error) <span class="cov8" title="1">{
        return s.analysisRepo.GetAllSessionIDs(ctx, limit)
}</span>

// FilenameTmplData contains template data for filename generation
type FilenameTmplData struct {
        SessionID  string
        PromptName string
        Date       string
        Time       string
}

// SaveToMarkdown saves an analysis to a markdown file
// outputDir: directory to save the file (empty uses config default)
// filename: filename override (empty uses config template)
func (s *AnalysisService) SaveToMarkdown(ctx context.Context, analysis *domain.SessionAnalysis, outputDir, filename string) (string, error) <span class="cov8" title="1">{
        if analysis == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("analysis is nil")
        }</span>

        // Use config default if outputDir not specified
        <span class="cov8" title="1">if outputDir == "" </span><span class="cov8" title="1">{
                outputDir = s.config.UI.DefaultOutputDir
                if outputDir == "" </span><span class="cov0" title="0">{
                        outputDir = "./analysis-outputs"
                }</span>
        }

        // Create output directory if it doesn't exist
        <span class="cov8" title="1">if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Generate filename if not specified
        <span class="cov8" title="1">if filename == "" </span><span class="cov8" title="1">{
                tmplStr := s.config.UI.FilenameTemplate
                if tmplStr == "" </span><span class="cov0" title="0">{
                        tmplStr = "{{.SessionID}}-{{.PromptName}}-{{.Date}}.md"
                }</span>

                // Parse and execute template
                <span class="cov8" title="1">tmpl, err := template.New("filename").Parse(tmplStr)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("invalid filename template: %w", err)
                }</span>

                <span class="cov8" title="1">now := time.Now()
                data := FilenameTmplData{
                        SessionID:  analysis.SessionID[:8], // Use first 8 chars of session ID
                        PromptName: analysis.PromptName,
                        Date:       now.Format("2006-01-02"),
                        Time:       now.Format("15-04-05"),
                }

                var buf bytes.Buffer
                if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to generate filename: %w", err)
                }</span>

                <span class="cov8" title="1">filename = buf.String()</span>
        }

        // Ensure .md extension
        <span class="cov8" title="1">if filepath.Ext(filename) != ".md" </span><span class="cov0" title="0">{
                filename = filename + ".md"
        }</span>

        // Build full path
        <span class="cov8" title="1">fullPath := filepath.Join(outputDir, filename)

        // Create markdown content
        content := fmt.Sprintf(`# Session Analysis: %s

**Session ID**: %s
**Analysis Type**: %s
**Prompt**: %s
**Model**: %s
**Analyzed At**: %s

---

%s
`,
                analysis.SessionID[:8],
                analysis.SessionID,
                analysis.AnalysisType,
                analysis.PromptName,
                analysis.ModelUsed,
                analysis.AnalyzedAt.Format(time.RFC3339),
                analysis.AnalysisResult,
        )

        // Write file
        if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to write file: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Saved analysis to %s", fullPath)
        return fullPath, nil</span>
}

// ClaudeCLIExecutor implements LLMExecutor using the claude CLI tool
type ClaudeCLIExecutor struct {
        logger Logger
        config *domain.Config
}

// NewClaudeCLIExecutor creates a new Claude CLI executor
func NewClaudeCLIExecutor(logger Logger) *ClaudeCLIExecutor <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = &amp;NoOpLogger{}
        }</span>
        <span class="cov8" title="1">return &amp;ClaudeCLIExecutor{
                logger: logger,
                config: domain.DefaultConfig(),
        }</span>
}

// NewClaudeCLIExecutorWithConfig creates a new Claude CLI executor with custom config
func NewClaudeCLIExecutorWithConfig(logger Logger, config *domain.Config) *ClaudeCLIExecutor <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = &amp;NoOpLogger{}
        }</span>
        <span class="cov8" title="1">if config == nil </span><span class="cov8" title="1">{
                config = domain.DefaultConfig()
        }</span>
        <span class="cov8" title="1">return &amp;ClaudeCLIExecutor{
                logger: logger,
                config: config,
        }</span>
}

// Execute runs claude -p with the given prompt
// Streams output to stderr in real-time for progress visibility
// The prompt parameter is treated as the user prompt unless config specifies system prompt mode
func (e *ClaudeCLIExecutor) Execute(ctx context.Context, prompt string) (string, error) <span class="cov0" title="0">{
        return e.ExecuteWithOptions(ctx, prompt, nil)
}</span>

// ExecuteWithOptions runs claude with custom options
// options can override config settings (model, tokenLimit, etc.)
func (e *ClaudeCLIExecutor) ExecuteWithOptions(ctx context.Context, prompt string, options map[string]interface{}) (string, error) <span class="cov0" title="0">{
        // Build command arguments (no -p flag, we'll use direct prompt)
        args := []string{}

        // Apply model from config or options
        model := e.config.Analysis.Model
        if opt, ok := options["model"].(string); ok &amp;&amp; opt != "" </span><span class="cov0" title="0">{
                model = opt
        }</span>
        <span class="cov0" title="0">if model != "" </span><span class="cov0" title="0">{
                args = append(args, "--model", model)
        }</span>

        <span class="cov0" title="0">var userPrompt string

        // Apply system prompt mode from config
        if e.config.Analysis.ClaudeOptions.SystemPromptMode == "replace" </span><span class="cov0" title="0">{
                args = append(args, "--system-prompt", prompt)
                // When using system prompt, we need a user prompt too
                userPrompt = "Analyze the session data provided in the system prompt."
        }</span> else<span class="cov0" title="0"> if e.config.Analysis.ClaudeOptions.SystemPromptMode == "append" </span><span class="cov0" title="0">{
                args = append(args, "--append-system-prompt", prompt)
                userPrompt = "Analyze the session data."
        }</span> else<span class="cov0" title="0"> {
                // No system prompt mode, use prompt directly
                userPrompt = prompt
        }</span>

        // Apply allowed tools from config
        <span class="cov0" title="0">if len(e.config.Analysis.ClaudeOptions.AllowedTools) &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, "--allowed-tools", strings.Join(e.config.Analysis.ClaudeOptions.AllowedTools, ","))
        }</span>

        // Add the user prompt last
        <span class="cov0" title="0">args = append(args, userPrompt)

        e.logger.Debug("Executing: claude %s", strings.Join(args, " "))
        cmd := exec.CommandContext(ctx, "claude", args...)

        var stdout, stderr bytes.Buffer

        // Use MultiWriter to stream to both the buffer and os.Stderr for real-time feedback
        cmd.Stdout = io.MultiWriter(&amp;stdout, os.Stderr)
        cmd.Stderr = io.MultiWriter(&amp;stderr, os.Stderr)

        e.logger.Debug("Running Claude CLI command...")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                e.logger.Error("Claude CLI command failed: %v", err)
                return "", fmt.Errorf("claude command failed: %w, stderr: %s", err, stderr.String())
        }</span>
        <span class="cov0" title="0">e.logger.Debug("Claude CLI command completed successfully")

        return strings.TrimSpace(stdout.String()), nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

// DefaultAnalysisPrompt is the template used for analyzing sessions
const DefaultAnalysisPrompt = `You are Claude Code, an AI agent that assists with software development.

Analyze your own work session below and identify what tools YOU need to make YOUR work more efficient.

## Your Task

Review your session and identify where YOU (the agent) were inefficient due to lack of tools. Specifically look for:

1. **Repetitive Low-Level Operations**: Where you had to perform multiple primitive operations that could be a single tool
2. **Missing Specialized Agents**: Task types that would benefit from dedicated subagents with specialized capabilities
3. **Tool Gaps**: Operations you struggled with or had to work around due to missing functionality
4. **Workflow Inefficiencies**: Multi-step sequences you repeat that should be automated

## Tool Categories to Consider

- **Specialized Agents**: Subagents with specific expertise (e.g., test generation, refactoring, documentation)
- **CLI Tools**: Command-line utilities that could be invoked via Bash to augment your capabilities
- **Claude Code Features**: New tools or capabilities that should be built into Claude Code itself
- **Workflow Automations**: Multi-step operations that should be single tool calls

## Output Format

Write your analysis from YOUR perspective as the agent. Use first person.

### What Made Me Inefficient
[Describe specific moments where you lacked the right tools, with examples from the session]

### Tools I Need

For each tool you need, state:

**Tool: [Name]**
- **What I Need**: Clear description of the capability
- **Why I Need It**: How it would make YOUR work more efficient (not the human's)
- **Type**: [Specialized Agent | CLI Tool | Claude Code Feature | Workflow Automation]
- **How I Would Use It**: Concrete example from this session showing how you would invoke it
- **Implementation Note**: Brief technical approach

### Priority Order

List the tools in priority order based on:
1. Frequency of need in your work
2. Time saved per invocation
3. Reduction in error-prone manual steps

Write as: "To make my work more efficient, I need: [ordered list]"

---

## Session to Analyze

`

// GetAnalysisPrompt returns the full analysis prompt with session data
func GetAnalysisPrompt(sessionMarkdown string) string <span class="cov8" title="1">{
        return DefaultAnalysisPrompt + sessionMarkdown
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        "context"
        "fmt"
        "io"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
)

// AnalyzeOptions contains options for the analyze command
type AnalyzeOptions struct {
        SessionID     string
        Last          bool
        ViewOnly      bool
        AnalyzeAll    bool
        Refresh       bool
        Limit         int
        PromptNames   []string
        ModelOverride string
        TokenLimit    int
}

// AnalysisServiceInterface defines the interface for analysis operations
type AnalysisServiceInterface interface {
        GetLastSession(ctx context.Context) (string, error)
        GetAnalysis(ctx context.Context, sessionID string) (*domain.SessionAnalysis, error)
        AnalyzeSessionWithPrompt(ctx context.Context, sessionID string, promptName string) (*domain.SessionAnalysis, error)
        GetUnanalyzedSessions(ctx context.Context) ([]string, error)
        GetAllSessionIDs(ctx context.Context, limit int) ([]string, error)
        AnalyzeSessionWithMultiplePrompts(ctx context.Context, sessionID string, promptNames []string) (map[string]*domain.SessionAnalysis, []error)
}

// AnalyzeCommandHandler handles the analyze command logic
type AnalyzeCommandHandler struct {
        analysisService AnalysisServiceInterface
        logger          Logger
        out             io.Writer
}

// NewAnalyzeCommandHandler creates a new analyze command handler
func NewAnalyzeCommandHandler(analysisService AnalysisServiceInterface, logger Logger, out io.Writer) *AnalyzeCommandHandler <span class="cov8" title="1">{
        return &amp;AnalyzeCommandHandler{
                analysisService: analysisService,
                logger:          logger,
                out:             out,
        }
}</span>

// Execute runs the analyze command based on options
func (h *AnalyzeCommandHandler) Execute(ctx context.Context, opts AnalyzeOptions) error <span class="cov8" title="1">{
        // Handle different modes
        if opts.Refresh </span><span class="cov8" title="1">{
                return h.refreshAnalyses(ctx, opts.Limit, opts.PromptNames)
        }</span>

        <span class="cov8" title="1">if opts.AnalyzeAll </span><span class="cov8" title="1">{
                return h.analyzeAllSessions(ctx, opts.PromptNames)
        }</span>

        // Determine which session to analyze
        <span class="cov8" title="1">var targetSessionID string
        if opts.SessionID != "" </span><span class="cov8" title="1">{
                targetSessionID = opts.SessionID
        }</span> else<span class="cov8" title="1"> if opts.Last </span><span class="cov8" title="1">{
                lastSessionID, err := h.analysisService.GetLastSession(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get last session: %w", err)
                }</span>
                <span class="cov8" title="1">targetSessionID = lastSessionID
                fmt.Fprintf(h.out, "Analyzing last session: %s\n\n", targetSessionID)</span>
        } else<span class="cov8" title="1"> {
                return fmt.Errorf("must specify --session-id or --last")
        }</span>

        // View existing analysis if requested
        <span class="cov8" title="1">if opts.ViewOnly </span><span class="cov8" title="1">{
                return h.viewAnalysis(ctx, targetSessionID)
        }</span>

        // Perform analysis
        <span class="cov8" title="1">return h.analyzeSession(ctx, targetSessionID, opts.PromptNames)</span>
}

// viewAnalysis displays an existing analysis
func (h *AnalyzeCommandHandler) viewAnalysis(ctx context.Context, sessionID string) error <span class="cov8" title="1">{
        analysis, err := h.analysisService.GetAnalysis(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get analysis: %w", err)
        }</span>

        <span class="cov8" title="1">if analysis == nil </span><span class="cov0" title="0">{
                fmt.Fprintf(h.out, "No analysis found for session %s\n", sessionID)
                fmt.Fprintln(h.out, "Run without --view to analyze this session")
                return fmt.Errorf("no analysis found")
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(h.out, "Session: %s\n", analysis.SessionID)
        fmt.Fprintf(h.out, "Analyzed at: %s\n", analysis.AnalyzedAt.Format("2006-01-02 15:04:05"))
        fmt.Fprintf(h.out, "Model: %s\n\n", analysis.ModelUsed)
        fmt.Fprintln(h.out, "=== Analysis Result ===")
        fmt.Fprintln(h.out, analysis.AnalysisResult)

        return nil</span>
}

// analyzeSession analyzes a single session with one or more prompts
func (h *AnalyzeCommandHandler) analyzeSession(ctx context.Context, sessionID string, promptNames []string) error <span class="cov8" title="1">{
        if len(promptNames) == 1 </span><span class="cov8" title="1">{
                // Single prompt - use simple sequential analysis
                fmt.Fprintf(h.out, "Analyzing session %s with prompt '%s'...\n", sessionID, promptNames[0])
                analysis, err := h.analysisService.AnalyzeSessionWithPrompt(ctx, sessionID, promptNames[0])
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to analyze session: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Fprintf(h.out, "\nAnalysis completed at %s\n\n", analysis.AnalyzedAt.Format("2006-01-02 15:04:05"))
                fmt.Fprintln(h.out, "=== Analysis Result ===")
                fmt.Fprintln(h.out, analysis.AnalysisResult)</span>
        } else<span class="cov8" title="1"> {
                // Multiple prompts - use parallel analysis
                fmt.Fprintf(h.out, "Analyzing session %s with %d prompts in parallel: %v\n", sessionID, len(promptNames), promptNames)
                analyses, errs := h.analysisService.AnalyzeSessionWithMultiplePrompts(ctx, sessionID, promptNames)

                if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintln(h.out, "\nErrors during analysis:")
                        for _, err := range errs </span><span class="cov0" title="0">{
                                fmt.Fprintf(h.out, "  - %v\n", err)
                        }</span>
                }

                <span class="cov8" title="1">if len(analyses) &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprintf(h.out, "\nCompleted %d/%d analyses successfully\n\n", len(analyses), len(promptNames))
                        for promptName, analysis := range analyses </span><span class="cov8" title="1">{
                                fmt.Fprintf(h.out, "=== Analysis: %s (completed at %s) ===\n", promptName, analysis.AnalyzedAt.Format("15:04:05"))
                                fmt.Fprintln(h.out, analysis.AnalysisResult)
                                fmt.Fprintln(h.out)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("all analyses failed")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// analyzeAllSessions analyzes all unanalyzed sessions
func (h *AnalyzeCommandHandler) analyzeAllSessions(ctx context.Context, promptNames []string) error <span class="cov8" title="1">{
        // Get unanalyzed sessions
        h.logger.Debug("Fetching unanalyzed sessions")
        sessionIDs, err := h.analysisService.GetUnanalyzedSessions(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get unanalyzed sessions: %v", err)
                return fmt.Errorf("failed to get unanalyzed sessions: %w", err)
        }</span>
        <span class="cov8" title="1">h.logger.Debug("Found %d unanalyzed sessions", len(sessionIDs))

        if len(sessionIDs) == 0 </span><span class="cov0" title="0">{
                h.logger.Info("No unanalyzed sessions found")
                fmt.Fprintln(h.out, "No unanalyzed sessions found")
                return nil
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(h.out, "Found %d unanalyzed session(s)\n", len(sessionIDs))
        fmt.Fprintf(h.out, "Using prompts: %v\n\n", promptNames)

        // Analyze each session with all prompts
        successCount := 0
        for i, sessionID := range sessionIDs </span><span class="cov8" title="1">{
                fmt.Fprintf(h.out, "[%d/%d] Analyzing session %s with %d prompt(s)...\n", i+1, len(sessionIDs), sessionID, len(promptNames))
                h.logger.Debug("Starting analysis for session %s (%d/%d)", sessionID, i+1, len(sessionIDs))

                if len(promptNames) == 1 </span><span class="cov8" title="1">{
                        // Single prompt - simple sequential
                        analysis, err := h.analysisService.AnalyzeSessionWithPrompt(ctx, sessionID, promptNames[0])
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(h.out, "Failed to analyze session %s: %v\n", sessionID, err)
                                h.logger.Warn("Analysis failed for session %s: %v", sessionID, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">successCount++
                        h.logger.Info("Analysis completed for session %s", sessionID)
                        fmt.Fprintf(h.out, "âœ“ Completed at %s\n\n", analysis.AnalyzedAt.Format("15:04:05"))</span>
                } else<span class="cov0" title="0"> {
                        // Multiple prompts - parallel
                        analyses, errs := h.analysisService.AnalyzeSessionWithMultiplePrompts(ctx, sessionID, promptNames)
                        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                                h.logger.Warn("Some analyses failed for session %s: %v", sessionID, errs)
                        }</span>
                        <span class="cov0" title="0">if len(analyses) &gt; 0 </span><span class="cov0" title="0">{
                                successCount++
                                h.logger.Info("Completed %d/%d analyses for session %s", len(analyses), len(promptNames), sessionID)
                                fmt.Fprintf(h.out, "âœ“ Completed %d/%d analyses\n\n", len(analyses), len(promptNames))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(h.out, "All analyses failed for session %s\n", sessionID)
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Fprintf(h.out, "\nAnalyzed %d/%d session(s) successfully\n", successCount, len(sessionIDs))
        h.logger.Info("Batch analysis complete: %d/%d successful", successCount, len(sessionIDs))

        return nil</span>
}

// refreshAnalyses re-analyzes existing sessions
func (h *AnalyzeCommandHandler) refreshAnalyses(ctx context.Context, limit int, promptNames []string) error <span class="cov8" title="1">{
        // Get all sessions (or latest N if limit is specified)
        h.logger.Debug("Fetching session IDs for refresh (limit: %d)", limit)
        sessionIDs, err := h.analysisService.GetAllSessionIDs(ctx, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("Failed to get session IDs: %v", err)
                return fmt.Errorf("failed to get session IDs: %w", err)
        }</span>
        <span class="cov8" title="1">h.logger.Debug("Found %d sessions to refresh", len(sessionIDs))

        if len(sessionIDs) == 0 </span><span class="cov0" title="0">{
                h.logger.Info("No sessions found to refresh")
                fmt.Fprintln(h.out, "No sessions found to refresh")
                return nil
        }</span>

        <span class="cov8" title="1">if limit &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(h.out, "Refreshing analyses for latest %d session(s)\n", len(sessionIDs))
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(h.out, "Refreshing analyses for all %d session(s)\n", len(sessionIDs))
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(h.out, "Using prompts: %v\n\n", promptNames)

        // Re-analyze each session with all prompts
        successCount := 0
        for i, sessionID := range sessionIDs </span><span class="cov8" title="1">{
                fmt.Fprintf(h.out, "[%d/%d] Re-analyzing session %s with %d prompt(s)...\n", i+1, len(sessionIDs), sessionID, len(promptNames))
                h.logger.Debug("Starting re-analysis for session %s (%d/%d)", sessionID, i+1, len(sessionIDs))

                if len(promptNames) == 1 </span><span class="cov8" title="1">{
                        // Single prompt - simple sequential
                        analysis, err := h.analysisService.AnalyzeSessionWithPrompt(ctx, sessionID, promptNames[0])
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(h.out, "Failed to re-analyze session %s: %v\n", sessionID, err)
                                h.logger.Warn("Re-analysis failed for session %s: %v", sessionID, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">successCount++
                        h.logger.Info("Re-analysis completed for session %s", sessionID)
                        fmt.Fprintf(h.out, "âœ“ Completed at %s\n\n", analysis.AnalyzedAt.Format("15:04:05"))</span>
                } else<span class="cov0" title="0"> {
                        // Multiple prompts - parallel
                        analyses, errs := h.analysisService.AnalyzeSessionWithMultiplePrompts(ctx, sessionID, promptNames)
                        if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                                h.logger.Warn("Some re-analyses failed for session %s: %v", sessionID, errs)
                        }</span>
                        <span class="cov0" title="0">if len(analyses) &gt; 0 </span><span class="cov0" title="0">{
                                successCount++
                                h.logger.Info("Completed %d/%d re-analyses for session %s", len(analyses), len(promptNames), sessionID)
                                fmt.Fprintf(h.out, "âœ“ Completed %d/%d analyses\n\n", len(analyses), len(promptNames))
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(h.out, "All re-analyses failed for session %s\n", sessionID)
                        }</span>
                }
        }

        <span class="cov8" title="1">fmt.Fprintf(h.out, "\nRefreshed %d/%d session(s) successfully\n", successCount, len(sessionIDs))
        h.logger.Info("Refresh complete: %d/%d successful", successCount, len(sessionIDs))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import (
        "context"
        "fmt"
        "strings"
        "sync"

        "github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// CommandRegistry manages command discovery and routing from plugins.
// It discovers commands from plugins that implement ICommandProvider.
type CommandRegistry struct {
        pluginRegistry *PluginRegistry
        logger         Logger
        commandCache   map[string]map[string]pluginsdk.Command // pluginName -&gt; commandName -&gt; Command
        mu             sync.RWMutex
}

// NewCommandRegistry creates a new command registry
func NewCommandRegistry(pluginRegistry *PluginRegistry, logger Logger) *CommandRegistry <span class="cov8" title="1">{
        return &amp;CommandRegistry{
                pluginRegistry: pluginRegistry,
                logger:         logger,
                commandCache:   make(map[string]map[string]pluginsdk.Command),
        }
}</span>

// GetCommand finds a command by plugin name and command name
func (r *CommandRegistry) GetCommand(pluginName, commandName string) (pluginsdk.Command, error) <span class="cov8" title="1">{
        r.mu.RLock()
        cached := r.commandCache[pluginName]
        r.mu.RUnlock()

        if cached != nil </span><span class="cov8" title="1">{
                if cmd, exists := cached[commandName]; exists </span><span class="cov8" title="1">{
                        return cmd, nil
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("command not found: %s %s", pluginName, commandName)</span>
        }

        // Load commands from plugin
        <span class="cov8" title="1">plugin, err := r.pluginRegistry.GetPlugin(pluginName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("plugin not found: %s", pluginName)
        }</span>

        <span class="cov8" title="1">cmdProvider, ok := plugin.(pluginsdk.ICommandProvider)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("plugin %s does not provide commands", pluginName)
        }</span>

        // Cache commands for this plugin
        <span class="cov8" title="1">commands := cmdProvider.GetCommands()
        r.mu.Lock()
        r.commandCache[pluginName] = make(map[string]pluginsdk.Command)
        for _, cmd := range commands </span><span class="cov8" title="1">{
                r.commandCache[pluginName][cmd.GetName()] = cmd
        }</span>
        <span class="cov8" title="1">r.mu.Unlock()

        // Try again from cache
        r.mu.RLock()
        cmd, exists := r.commandCache[pluginName][commandName]
        r.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("command not found: %s %s", pluginName, commandName)
        }</span>

        <span class="cov8" title="1">return cmd, nil</span>
}

// GetCommandsForPlugin returns all commands from a specific plugin
func (r *CommandRegistry) GetCommandsForPlugin(pluginName string) []pluginsdk.Command <span class="cov8" title="1">{
        r.mu.RLock()
        cached := r.commandCache[pluginName]
        r.mu.RUnlock()

        if cached != nil </span><span class="cov0" title="0">{
                commands := make([]pluginsdk.Command, 0, len(cached))
                for _, cmd := range cached </span><span class="cov0" title="0">{
                        commands = append(commands, cmd)
                }</span>
                <span class="cov0" title="0">return commands</span>
        }

        // Load commands from plugin
        <span class="cov8" title="1">plugin, err := r.pluginRegistry.GetPlugin(pluginName)
        if err != nil </span><span class="cov8" title="1">{
                r.logger.Debug("Plugin not found: %s", pluginName)
                return nil
        }</span>

        <span class="cov8" title="1">cmdProvider, ok := plugin.(pluginsdk.ICommandProvider)
        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">commands := cmdProvider.GetCommands()

        // Cache commands
        r.mu.Lock()
        r.commandCache[pluginName] = make(map[string]pluginsdk.Command)
        for _, cmd := range commands </span><span class="cov8" title="1">{
                r.commandCache[pluginName][cmd.GetName()] = cmd
        }</span>
        <span class="cov8" title="1">r.mu.Unlock()

        return commands</span>
}

// GetAllCommands returns all commands from all plugins
func (r *CommandRegistry) GetAllCommands() map[string][]pluginsdk.Command <span class="cov8" title="1">{
        allPlugins := r.pluginRegistry.GetAllPlugins()
        result := make(map[string][]pluginsdk.Command)

        for _, plugin := range allPlugins </span><span class="cov8" title="1">{
                cmdProvider, ok := plugin.(pluginsdk.ICommandProvider)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">pluginName := plugin.GetInfo().Name
                commands := cmdProvider.GetCommands()

                if len(commands) &gt; 0 </span><span class="cov8" title="1">{
                        result[pluginName] = commands

                        // Update cache
                        r.mu.Lock()
                        r.commandCache[pluginName] = make(map[string]pluginsdk.Command)
                        for _, cmd := range commands </span><span class="cov8" title="1">{
                                r.commandCache[pluginName][cmd.GetName()] = cmd
                        }</span>
                        <span class="cov8" title="1">r.mu.Unlock()</span>
                }
        }

        <span class="cov8" title="1">return result</span>
}

// ExecuteCommand executes a command from a plugin
func (r *CommandRegistry) ExecuteCommand(ctx context.Context, pluginName, commandName string, args []string, cmdCtx pluginsdk.CommandContext) error <span class="cov8" title="1">{
        cmd, err := r.GetCommand(pluginName, commandName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check for --help or -h flag
        <span class="cov8" title="1">if containsHelp(args) </span><span class="cov0" title="0">{
                r.printCommandHelp(pluginName, cmd, cmdCtx)
                return nil
        }</span>

        <span class="cov8" title="1">r.logger.Debug("Executing command: %s %s", pluginName, commandName)
        return cmd.Execute(ctx, cmdCtx, args)</span>
}

// containsHelp checks if args contains --help or -h
func containsHelp(args []string) bool <span class="cov8" title="1">{
        for _, arg := range args </span><span class="cov8" title="1">{
                if arg == "--help" || arg == "-h" </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// printCommandHelp displays help for a command
func (r *CommandRegistry) printCommandHelp(pluginName string, cmd pluginsdk.Command, cmdCtx pluginsdk.CommandContext) <span class="cov0" title="0">{
        output := cmdCtx.GetStdout()

        // Command header
        fmt.Fprintf(output, "Command: dw %s %s\n\n", pluginName, cmd.GetName())

        // Description
        fmt.Fprintf(output, "Description:\n  %s\n\n", cmd.GetDescription())

        // Usage
        fmt.Fprintf(output, "Usage:\n  %s\n\n", cmd.GetUsage())

        // Detailed help (if provided)
        if help := cmd.GetHelp(); help != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(output, "%s\n", help)
        }</span>
}

// ListCommands returns formatted list of all plugin commands
func (r *CommandRegistry) ListCommands() string <span class="cov8" title="1">{
        allCommands := r.GetAllCommands()

        if len(allCommands) == 0 </span><span class="cov8" title="1">{
                return "No plugin commands available"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString("Available plugin commands:\n\n")

        for pluginName, commands := range allCommands </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("%s:\n", pluginName))
                for _, cmd := range commands </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("  dw %s %s - %s\n", pluginName, cmd.GetName(), cmd.GetDescription()))
                        if usage := cmd.GetUsage(); usage != "" </span><span class="cov8" title="1">{
                                sb.WriteString(fmt.Sprintf("    Usage: dw %s %s\n", pluginName, usage))
                        }</span>
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return sb.String()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "context"
        "fmt"
        "io"
)

// ConfigCommandHandler handles config command operations
type ConfigCommandHandler struct {
        configLoader ConfigLoader
        logger       Logger
        output       io.Writer
}

// NewConfigCommandHandler creates a new config command handler
func NewConfigCommandHandler(
        configLoader ConfigLoader,
        logger Logger,
        output io.Writer,
) *ConfigCommandHandler <span class="cov8" title="1">{
        return &amp;ConfigCommandHandler{
                configLoader: configLoader,
                logger:       logger,
                output:       output,
        }
}</span>

// Init creates a default configuration file
func (h *ConfigCommandHandler) Init(ctx context.Context, configPath string, force bool) error <span class="cov8" title="1">{
        // Create and save default config
        // The config loader will check if file exists and handle force flag
        createdPath, err := h.configLoader.InitializeDefaultConfig(configPath)
        if err != nil </span><span class="cov8" title="1">{
                // Check if error is because file already exists
                if !force </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to create config: %w (use --force to overwrite existing file)", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create config: %w", err)</span>
        }

        <span class="cov8" title="1">fmt.Fprintf(h.output, "Created config file: %s\n", createdPath)
        fmt.Fprintln(h.output, "\nYou can now customize the prompts in this file for your project.")

        return nil</span>
}

// Show displays the current configuration
func (h *ConfigCommandHandler) Show(ctx context.Context) error <span class="cov8" title="1">{
        config, err := h.configLoader.LoadConfig("")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Fprintln(h.output, "=== DarwinFlow Configuration ===")
        fmt.Fprintf(h.output, "\nPrompts defined: %d\n", len(config.Prompts))
        for name := range config.Prompts </span><span class="cov8" title="1">{
                fmt.Fprintf(h.output, "  - %s\n", name)
        }</span>
        <span class="cov8" title="1">fmt.Fprintln(h.output, "\nTo edit prompts, modify .darwinflow.yaml in your project root")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "context"
        "fmt"
        "sync"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
        "github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// EventDispatcher manages async event streams from multiple plugins.
// It provides a central buffered channel where plugins push events,
// and a background goroutine that consumes and persists them.
//
// This enables real-time event streaming from multiple sources without
// blocking plugin operations.
type EventDispatcher struct {
        eventChan    chan pluginsdk.Event
        eventRepo    domain.EventRepository
        logger       Logger
        emitters     []pluginsdk.IEventEmitter
        ctx          context.Context
        cancel       context.CancelFunc
        wg           sync.WaitGroup
        mu           sync.RWMutex
        running      bool
        pluginCtx    pluginsdk.PluginContext
        eventCounter int64 // For metrics/debugging
}

const (
        // EventChannelBuffer is the size of the buffered event channel.
        // This allows plugins to emit bursts of events without blocking.
        EventChannelBuffer = 100
)

// NewEventDispatcher creates a new event dispatcher.
func NewEventDispatcher(
        eventRepo domain.EventRepository,
        logger Logger,
        pluginCtx pluginsdk.PluginContext,
) *EventDispatcher <span class="cov8" title="1">{
        return &amp;EventDispatcher{
                eventChan: make(chan pluginsdk.Event, EventChannelBuffer),
                eventRepo: eventRepo,
                logger:    logger,
                emitters:  make([]pluginsdk.IEventEmitter, 0),
                pluginCtx: pluginCtx,
        }
}</span>

// RegisterEmitter registers a plugin that implements IEventEmitter.
// This should be called during plugin registration, before Start().
func (d *EventDispatcher) RegisterEmitter(emitter pluginsdk.IEventEmitter) <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        d.emitters = append(d.emitters, emitter)
        pluginInfo := emitter.GetInfo()
        d.logger.Debug("Registered event emitter: %s", pluginInfo.Name)
}</span>

// Start begins background event processing.
// It starts the consumer goroutine and tells all registered emitters to begin streaming.
func (d *EventDispatcher) Start(ctx context.Context) error <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if d.running </span><span class="cov0" title="0">{
                return fmt.Errorf("event dispatcher already running")
        }</span>

        // Create cancellable context
        <span class="cov8" title="1">d.ctx, d.cancel = context.WithCancel(ctx)

        // Start consumer goroutine
        d.wg.Add(1)
        go d.consumeEvents()

        // Start all registered emitters
        for _, emitter := range d.emitters </span><span class="cov8" title="1">{
                if err := emitter.StartEventStream(d.ctx, d.eventChan); err != nil </span><span class="cov0" title="0">{
                        pluginInfo := emitter.GetInfo()
                        d.logger.Warn("Failed to start event stream for %s: %v", pluginInfo.Name, err)
                        // Continue with other emitters even if one fails
                }</span> else<span class="cov8" title="1"> {
                        pluginInfo := emitter.GetInfo()
                        d.logger.Info("Started event stream for plugin: %s", pluginInfo.Name)
                }</span>
        }

        <span class="cov8" title="1">d.running = true
        d.logger.Info("EventDispatcher started with %d emitters", len(d.emitters))

        return nil</span>
}

// Stop gracefully shuts down the dispatcher.
// It stops all emitters, drains the event channel, and waits for goroutines to finish.
func (d *EventDispatcher) Stop() error <span class="cov8" title="1">{
        d.mu.Lock()
        if !d.running </span><span class="cov8" title="1">{
                d.mu.Unlock()
                return fmt.Errorf("event dispatcher not running")
        }</span>

        <span class="cov8" title="1">d.logger.Info("Stopping EventDispatcher...")

        // Stop all emitters first
        for _, emitter := range d.emitters </span><span class="cov8" title="1">{
                if err := emitter.StopEventStream(); err != nil </span><span class="cov0" title="0">{
                        pluginInfo := emitter.GetInfo()
                        d.logger.Warn("Error stopping event stream for %s: %v", pluginInfo.Name, err)
                }</span>
        }

        // Cancel context to signal consumer to stop
        <span class="cov8" title="1">d.cancel()
        d.running = false
        d.mu.Unlock()

        // Wait for consumer goroutine to finish
        d.wg.Wait()

        d.logger.Info("EventDispatcher stopped (processed %d events)", d.eventCounter)

        return nil</span>
}

// consumeEvents is the background goroutine that processes events from the channel.
// It runs until the context is cancelled and the channel is drained.
func (d *EventDispatcher) consumeEvents() <span class="cov8" title="1">{
        defer d.wg.Done()

        d.logger.Debug("Event consumer goroutine started")

        for </span><span class="cov8" title="1">{
                select </span>{
                case event, ok := &lt;-d.eventChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                // Channel closed, exit
                                d.logger.Debug("Event channel closed, consumer exiting")
                                return
                        }</span>

                        // Process the event
                        <span class="cov8" title="1">if err := d.processEvent(event); err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("Failed to process event %s from %s: %v",
                                        event.Type, event.Source, err)
                        }</span> else<span class="cov8" title="1"> {
                                d.eventCounter++
                        }</span>

                case &lt;-d.ctx.Done():<span class="cov8" title="1">
                        // Context cancelled, drain remaining events then exit
                        d.logger.Debug("Context cancelled, draining event channel...")
                        d.drainChannel()
                        return</span>
                }
        }
}

// processEvent persists a single event to the repository.
func (d *EventDispatcher) processEvent(event pluginsdk.Event) error <span class="cov8" title="1">{
        // Use the plugin context adapter to convert SDK event to domain event
        // This reuses the existing conversion logic in pluginContextAdapter
        return d.pluginCtx.EmitEvent(context.Background(), event)
}</span>

// drainChannel processes any remaining events in the channel before shutdown.
func (d *EventDispatcher) drainChannel() <span class="cov8" title="1">{
        drained := 0
        for </span><span class="cov8" title="1">{
                select </span>{
                case event, ok := &lt;-d.eventChan:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                d.logger.Debug("Drained %d events during shutdown", drained)
                                return
                        }</span>
                        <span class="cov0" title="0">if err := d.processEvent(event); err != nil </span><span class="cov0" title="0">{
                                d.logger.Error("Failed to process event during drain: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                drained++
                                d.eventCounter++
                        }</span>
                default:<span class="cov8" title="1">
                        // Channel empty
                        d.logger.Debug("Drained %d events during shutdown", drained)
                        return</span>
                }
        }
}

// GetMetrics returns current dispatcher metrics (for monitoring/debugging).
func (d *EventDispatcher) GetMetrics() map[string]interface{} <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()

        return map[string]interface{}{
                "running":        d.running,
                "emitter_count":  len(d.emitters),
                "events_handled": d.eventCounter,
                "channel_len":    len(d.eventChan),
                "channel_cap":    cap(d.eventChan),
        }
}</span>

// GetEventChannel returns a read-only channel for subscribing to events.
// This allows multiple consumers to listen to the event stream.
// The returned channel receives copies of all events processed by the dispatcher.
func (d *EventDispatcher) GetEventChannel() &lt;-chan pluginsdk.Event <span class="cov0" title="0">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        return d.eventChan
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
)

// EventMapper maps string event types to normalized event type strings
// This is used to normalize various event type formats to canonical strings
type EventMapper struct{}

// MapEventType maps string event types to normalized event type strings
// The returned string can be any event type identifier defined by plugins
func (m *EventMapper) MapEventType(eventTypeStr string) string <span class="cov8" title="1">{
        // Normalize the string
        normalized := strings.ToLower(strings.ReplaceAll(eventTypeStr, "_", "."))

        switch normalized </span>{
        case "chat.started":<span class="cov8" title="1">
                return "claude.chat.started"</span>
        case "chat.ended", "chat.end":<span class="cov8" title="1">
                return "claude.chat.started"</span> // Reuse for now
        case "chat.message.user", "user.message":<span class="cov8" title="1">
                return "claude.chat.message.user"</span>
        case "chat.message.assistant", "assistant.message":<span class="cov8" title="1">
                return "claude.chat.message.assistant"</span>
        case "tool.invoked", "tool.invoke":<span class="cov8" title="1">
                return "claude.tool.invoked"</span>
        case "tool.result":<span class="cov8" title="1">
                return "claude.tool.result"</span>
        case "file.read":<span class="cov8" title="1">
                return "claude.file.read"</span>
        case "file.written", "file.write":<span class="cov8" title="1">
                return "claude.file.written"</span>
        case "context.changed", "context.change":<span class="cov8" title="1">
                return "claude.context.changed"</span>
        case "error":<span class="cov8" title="1">
                return "claude.error"</span>
        default:<span class="cov8" title="1">
                // Default to generic event with claude. prefix
                return "claude." + normalized</span>
        }
}

// TranscriptParser defines the interface for parsing Claude Code transcripts
type TranscriptParser interface {
        ExtractLastToolUse(transcriptPath string, maxParamLength int) (string, string, error)
        ExtractLastUserMessage(transcriptPath string) (string, error)
        ExtractLastAssistantMessage(transcriptPath string) (string, error)
}

// ContextDetector defines the interface for detecting context
type ContextDetector interface {
        DetectContext() string
}

// ContentNormalizer defines the interface for normalizing content for search
type ContentNormalizer func(eventType, payload string) string

// LoggerService orchestrates event logging for Claude Code interactions
type LoggerService struct {
        repository        domain.EventRepository
        transcriptParser  TranscriptParser
        contextDetector   ContextDetector
        contentNormalizer ContentNormalizer
        context           string
        sessionID         string
}

// NewLoggerService creates a new logger service
func NewLoggerService(
        repository domain.EventRepository,
        transcriptParser TranscriptParser,
        contextDetector ContextDetector,
        contentNormalizer ContentNormalizer,
) *LoggerService <span class="cov8" title="1">{
        return &amp;LoggerService{
                repository:        repository,
                transcriptParser:  transcriptParser,
                contextDetector:   contextDetector,
                contentNormalizer: contentNormalizer,
                context:           contextDetector.DetectContext(),
        }
}</span>

// LogEvent logs a domain event
func (s *LoggerService) LogEvent(ctx context.Context, eventType string, payload interface{}) error <span class="cov8" title="1">{
        // Create normalized content for full-text search
        payloadJSON, err := json.Marshal(payload)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov8" title="1">content := s.contentNormalizer(eventType, string(payloadJSON))

        // Create domain event
        event := domain.NewEvent(eventType, s.sessionID, payload, content)

        // Save to repository
        if err := s.repository.Save(ctx, event); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save event: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Close closes the logger service and underlying repository
func (s *LoggerService) Close() error <span class="cov8" title="1">{
        return s.repository.Close()
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "context"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "io"
        "sort"
        "time"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
        "github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// LogRecord represents a formatted log entry for display
type LogRecord struct {
        ID        string
        Timestamp time.Time
        EventType string
        SessionID string
        Payload   json.RawMessage
        Content   string
}

// LogsService provides methods for querying and displaying logs
type LogsService struct {
        repo        domain.EventRepository
        rawExecutor pluginsdk.RawQueryExecutor
}

// NewLogsService creates a new logs service
func NewLogsService(repo domain.EventRepository, rawExecutor pluginsdk.RawQueryExecutor) *LogsService <span class="cov8" title="1">{
        return &amp;LogsService{
                repo:        repo,
                rawExecutor: rawExecutor,
        }
}</span>

// ListRecentLogs retrieves the most recent N logs, optionally filtered by session ID and ordered chronologically
// If sessionLimit &gt; 0, limits by number of sessions instead of number of events
func (s *LogsService) ListRecentLogs(ctx context.Context, limit int, sessionLimit int, sessionID string, ordered bool) ([]*LogRecord, error) <span class="cov8" title="1">{
        // If sessionLimit is specified, we need to first find the N most recent sessions
        // and then fetch all events for those sessions
        if sessionLimit &gt; 0 &amp;&amp; sessionID == "" </span><span class="cov8" title="1">{
                // Use raw query executor to find recent session IDs
                sessionQuery := fmt.Sprintf(`
                        SELECT session_id
                        FROM events
                        WHERE session_id IS NOT NULL AND session_id != ''
                        GROUP BY session_id
                        ORDER BY MAX(timestamp) DESC
                        LIMIT %d
                `, sessionLimit)

                result, err := s.rawExecutor.ExecuteRawQuery(ctx, sessionQuery)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get recent sessions: %w", err)
                }</span>

                // Extract session IDs
                <span class="cov8" title="1">sessionIDs := make([]string, 0, len(result.Rows))
                for _, row := range result.Rows </span><span class="cov8" title="1">{
                        if len(row) &gt; 0 </span><span class="cov8" title="1">{
                                if sessionIDStr, ok := row[0].(string); ok </span><span class="cov8" title="1">{
                                        sessionIDs = append(sessionIDs, sessionIDStr)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if len(sessionIDs) == 0 </span><span class="cov0" title="0">{
                        return []*LogRecord{}, nil
                }</span>

                // Fetch all events for these sessions
                <span class="cov8" title="1">return s.fetchEventsForSessions(ctx, sessionIDs, ordered)</span>
        }

        // Original behavior: limit by number of events
        <span class="cov8" title="1">query := pluginsdk.EventQuery{
                Limit:       limit,
                OrderByTime: ordered,
        }

        // Map sessionID to Metadata if provided
        if sessionID != "" </span><span class="cov8" title="1">{
                query.Metadata = map[string]string{"session_id": sessionID}
        }</span>

        <span class="cov8" title="1">events, err := s.repo.FindByQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query logs: %w", err)
        }</span>

        <span class="cov8" title="1">return s.convertEventsToRecords(events)</span>
}

// fetchEventsForSessions fetches all events for the given session IDs
func (s *LogsService) fetchEventsForSessions(ctx context.Context, sessionIDs []string, ordered bool) ([]*LogRecord, error) <span class="cov8" title="1">{
        allRecords := make([]*LogRecord, 0)

        for _, sessionID := range sessionIDs </span><span class="cov8" title="1">{
                query := pluginsdk.EventQuery{
                        OrderByTime: ordered,
                        Limit:       0, // No limit for individual sessions
                        Metadata:    map[string]string{"session_id": sessionID},
                }

                events, err := s.repo.FindByQuery(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to query logs for session %s: %w", sessionID, err)
                }</span>

                <span class="cov8" title="1">records, err := s.convertEventsToRecords(events)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">allRecords = append(allRecords, records...)</span>
        }

        // Sort all records by timestamp (most recent first) unless ordered is true
        <span class="cov8" title="1">if !ordered </span><span class="cov8" title="1">{
                sort.Slice(allRecords, func(i, j int) bool </span><span class="cov8" title="1">{
                        return allRecords[i].Timestamp.After(allRecords[j].Timestamp)
                }</span>)
        } else<span class="cov0" title="0"> {
                sort.Slice(allRecords, func(i, j int) bool </span><span class="cov0" title="0">{
                        return allRecords[i].Timestamp.Before(allRecords[j].Timestamp)
                }</span>)
        }

        <span class="cov8" title="1">return allRecords, nil</span>
}

// convertEventsToRecords converts domain events to log records
func (s *LogsService) convertEventsToRecords(events []*domain.Event) ([]*LogRecord, error) <span class="cov8" title="1">{
        records := make([]*LogRecord, len(events))
        for i, event := range events </span><span class="cov8" title="1">{
                payloadBytes, err := event.MarshalPayload()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal payload: %w", err)
                }</span>

                <span class="cov8" title="1">records[i] = &amp;LogRecord{
                        ID:        event.ID,
                        Timestamp: event.Timestamp,
                        EventType: string(event.Type),
                        SessionID: event.SessionID,
                        Payload:   payloadBytes,
                        Content:   event.Content,
                }</span>
        }

        <span class="cov8" title="1">return records, nil</span>
}

// ExecuteRawQuery executes an arbitrary SQL query
func (s *LogsService) ExecuteRawQuery(ctx context.Context, query string) (*pluginsdk.QueryResult, error) <span class="cov8" title="1">{
        return s.rawExecutor.ExecuteRawQuery(ctx, query)
}</span>

// FormatLogRecord formats a single log record for display
func FormatLogRecord(index int, record *LogRecord) string <span class="cov8" title="1">{
        var output string

        output += fmt.Sprintf("[%d] %s\n", index+1, record.Timestamp.Format("2006-01-02 15:04:05.000"))
        output += fmt.Sprintf("    Event: %s\n", record.EventType)
        output += fmt.Sprintf("    ID: %s\n", record.ID)
        if record.SessionID != "" </span><span class="cov8" title="1">{
                output += fmt.Sprintf("    Session: %s\n", record.SessionID)
        }</span>

        // Pretty print JSON payload with nested JSON expansion
        <span class="cov8" title="1">var payload interface{}
        if err := json.Unmarshal(record.Payload, &amp;payload); err == nil </span><span class="cov8" title="1">{
                // Expand nested JSON strings in the payload
                expandedPayload := expandNestedJSON(payload)
                prettyPayload, _ := json.MarshalIndent(expandedPayload, "    ", "  ")
                output += fmt.Sprintf("    Payload: %s\n", string(prettyPayload))
        }</span> else<span class="cov8" title="1"> {
                output += fmt.Sprintf("    Payload: %s\n", string(record.Payload))
        }</span>

        <span class="cov8" title="1">if record.Content != "" </span><span class="cov8" title="1">{
                // Truncate content if too long
                content := record.Content
                if len(content) &gt; 200 </span><span class="cov8" title="1">{
                        content = content[:200] + "..."
                }</span>
                <span class="cov8" title="1">output += fmt.Sprintf("    Content: %s\n", content)</span>
        }

        <span class="cov8" title="1">output += "\n"
        return output</span>
}

// expandNestedJSON recursively expands JSON strings within a data structure
func expandNestedJSON(data interface{}) interface{} <span class="cov8" title="1">{
        switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                // Recursively process map values
                result := make(map[string]interface{})
                for key, value := range v </span><span class="cov8" title="1">{
                        result[key] = expandNestedJSON(value)
                }</span>
                <span class="cov8" title="1">return result</span>

        case []interface{}:<span class="cov8" title="1">
                // Recursively process array elements
                result := make([]interface{}, len(v))
                for i, value := range v </span><span class="cov8" title="1">{
                        result[i] = expandNestedJSON(value)
                }</span>
                <span class="cov8" title="1">return result</span>

        case string:<span class="cov8" title="1">
                // Try to parse string as JSON
                if len(v) &gt; 0 &amp;&amp; (v[0] == '{' || v[0] == '[') </span><span class="cov8" title="1">{
                        var parsed interface{}
                        if err := json.Unmarshal([]byte(v), &amp;parsed); err == nil </span><span class="cov8" title="1">{
                                // Successfully parsed, recursively expand
                                return expandNestedJSON(parsed)
                        }</span>
                }
                // Not JSON or parsing failed, return as-is
                <span class="cov8" title="1">return v</span>

        default:<span class="cov8" title="1">
                // Return other types as-is
                return v</span>
        }
}

// FormatQueryValue formats a value from a raw query result for display
func FormatQueryValue(val interface{}) string <span class="cov8" title="1">{
        switch v := val.(type) </span>{
        case nil:<span class="cov8" title="1">
                return "NULL"</span>
        case []byte:<span class="cov8" title="1">
                // Try to parse as JSON for pretty printing
                var jsonObj interface{}
                if err := json.Unmarshal(v, &amp;jsonObj); err == nil </span><span class="cov8" title="1">{
                        jsonBytes, _ := json.Marshal(jsonObj)
                        str := string(jsonBytes)
                        if len(str) &gt; 100 </span><span class="cov0" title="0">{
                                str = str[:100] + "..."
                        }</span>
                        <span class="cov8" title="1">return str</span>
                }
                <span class="cov8" title="1">str := string(v)
                if len(str) &gt; 100 </span><span class="cov0" title="0">{
                        str = str[:100] + "..."
                }</span>
                <span class="cov8" title="1">return str</span>
        case string:<span class="cov8" title="1">
                if len(v) &gt; 100 </span><span class="cov8" title="1">{
                        return v[:100] + "..."
                }</span>
                <span class="cov8" title="1">return v</span>
        case int64:<span class="cov8" title="1">
                // Check if it might be a timestamp (13 digits for milliseconds)
                if v &gt; 1000000000000 &amp;&amp; v &lt; 9999999999999 </span><span class="cov8" title="1">{
                        t := time.UnixMilli(v)
                        return fmt.Sprintf("%d (%s)", v, t.Format("2006-01-02 15:04:05"))
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%d", v)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", v)</span>
        }
}

// FormatLogsAsCSV writes log records as CSV to the provided writer
func FormatLogsAsCSV(w io.Writer, records []*LogRecord) error <span class="cov8" title="1">{
        csvWriter := csv.NewWriter(w)
        defer csvWriter.Flush()

        // Write header
        header := []string{"ID", "Timestamp", "EventType", "SessionID", "Payload", "Content"}
        if err := csvWriter.Write(header); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write CSV header: %w", err)
        }</span>

        // Write records
        <span class="cov8" title="1">for _, record := range records </span><span class="cov8" title="1">{
                row := []string{
                        record.ID,
                        record.Timestamp.Format(time.RFC3339),
                        record.EventType,
                        record.SessionID,
                        string(record.Payload),
                        record.Content,
                }
                if err := csvWriter.Write(row); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write CSV row: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// FormatLogsAsMarkdown writes log records as Markdown to the provided writer
// Groups events by session and orders chronologically for LLM-friendly reading
func FormatLogsAsMarkdown(w io.Writer, records []*LogRecord) error <span class="cov8" title="1">{
        if len(records) == 0 </span><span class="cov8" title="1">{
                fmt.Fprintln(w, "# Event Logs")
                fmt.Fprintln(w)
                fmt.Fprintln(w, "No events found.")
                return nil
        }</span>

        // Group records by session
        <span class="cov8" title="1">sessions := groupRecordsBySession(records)

        // Sort sessions by first event timestamp
        sortSessionsByTime(sessions)

        // Write output
        fmt.Fprintln(w, "# Event Logs")
        fmt.Fprintln(w)
        fmt.Fprintf(w, "This document contains %d event(s) across %d session(s).\n", len(records), len(sessions))
        fmt.Fprintln(w)

        for sessionIdx, session := range sessions </span><span class="cov8" title="1">{
                // Session header
                if session.SessionID != "" </span><span class="cov8" title="1">{
                        fmt.Fprintf(w, "## Session %d: `%s`\n\n", sessionIdx+1, session.SessionID)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(w, "## Session %d: (No Session ID)\n\n", sessionIdx+1)
                }</span>

                // Session metadata
                <span class="cov8" title="1">fmt.Fprintf(w, "**Session started**: %s\n\n", session.StartTime.Format("2006-01-02 15:04:05 MST"))
                fmt.Fprintf(w, "**Session duration**: %s\n\n", session.EndTime.Sub(session.StartTime).Round(time.Millisecond))
                fmt.Fprintf(w, "**Total events**: %d\n\n", len(session.Records))

                // Events in chronological order
                fmt.Fprintln(w, "### Event Timeline")
                fmt.Fprintln(w)

                for eventIdx, record := range session.Records </span><span class="cov8" title="1">{
                        // Use narrative language
                        var prefix string
                        if eventIdx == 0 </span><span class="cov8" title="1">{
                                prefix = "**Session started** - "
                        }</span> else<span class="cov8" title="1"> {
                                prefix = fmt.Sprintf("**Step %d** - ", eventIdx+1)
                        }</span>

                        // Event type and timestamp
                        <span class="cov8" title="1">duration := record.Timestamp.Sub(session.StartTime)
                        fmt.Fprintf(w, "%s`%s` *(+%s)*\n\n", prefix, record.EventType, duration.Round(time.Millisecond))

                        // Payload - expanded and formatted
                        fmt.Fprintln(w, "**Details**:")
                        fmt.Fprintln(w)

                        var payload interface{}
                        if err := json.Unmarshal(record.Payload, &amp;payload); err == nil </span><span class="cov8" title="1">{
                                // Expand nested JSON strings
                                expandedPayload := expandNestedJSON(payload)
                                if err := formatMarkdownPayload(w, expandedPayload, 0); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to format payload: %w", err)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                fmt.Fprintf(w, "```\n%s\n```\n", string(record.Payload))
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintln(w)</span>
                }

                <span class="cov8" title="1">fmt.Fprintln(w, "---")
                fmt.Fprintln(w)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SessionGroup represents events grouped by session
type SessionGroup struct {
        SessionID string
        Records   []*LogRecord
        StartTime time.Time
        EndTime   time.Time
}

// groupRecordsBySession groups log records by session ID and sorts chronologically
func groupRecordsBySession(records []*LogRecord) []*SessionGroup <span class="cov8" title="1">{
        sessionMap := make(map[string]*SessionGroup)

        for _, record := range records </span><span class="cov8" title="1">{
                sessionID := record.SessionID
                if sessionID == "" </span><span class="cov0" title="0">{
                        sessionID = "(no-session)"
                }</span>

                <span class="cov8" title="1">session, exists := sessionMap[sessionID]
                if !exists </span><span class="cov8" title="1">{
                        session = &amp;SessionGroup{
                                SessionID: record.SessionID,
                                Records:   []*LogRecord{},
                                StartTime: record.Timestamp,
                                EndTime:   record.Timestamp,
                        }
                        sessionMap[sessionID] = session
                }</span>

                <span class="cov8" title="1">session.Records = append(session.Records, record)

                // Update start/end times
                if record.Timestamp.Before(session.StartTime) </span><span class="cov0" title="0">{
                        session.StartTime = record.Timestamp
                }</span>
                <span class="cov8" title="1">if record.Timestamp.After(session.EndTime) </span><span class="cov8" title="1">{
                        session.EndTime = record.Timestamp
                }</span>
        }

        // Sort records within each session chronologically
        <span class="cov8" title="1">for _, session := range sessionMap </span><span class="cov8" title="1">{
                sort.Slice(session.Records, func(i, j int) bool </span><span class="cov8" title="1">{
                        return session.Records[i].Timestamp.Before(session.Records[j].Timestamp)
                }</span>)
        }

        // Convert map to slice
        <span class="cov8" title="1">sessions := make([]*SessionGroup, 0, len(sessionMap))
        for _, session := range sessionMap </span><span class="cov8" title="1">{
                sessions = append(sessions, session)
        }</span>

        <span class="cov8" title="1">return sessions</span>
}

// sortSessionsByTime sorts sessions by their start time (most recent first)
func sortSessionsByTime(sessions []*SessionGroup) <span class="cov8" title="1">{
        sort.Slice(sessions, func(i, j int) bool </span><span class="cov0" title="0">{
                return sessions[i].StartTime.After(sessions[j].StartTime)
        }</span>)
}

// formatMarkdownPayload recursively formats a payload structure as Markdown
func formatMarkdownPayload(w io.Writer, data interface{}, depth int) error <span class="cov8" title="1">{
        return formatMarkdownPayloadWithContext(w, data, depth, nil)
}</span>

// formatMarkdownPayloadWithContext formats payload with awareness of parent context (e.g., tool name)
func formatMarkdownPayloadWithContext(w io.Writer, data interface{}, depth int, ctx map[string]interface{}) error <span class="cov8" title="1">{
        indent := ""
        for i := 0; i &lt; depth; i++ </span><span class="cov8" title="1">{
                indent += "  "
        }</span>

        <span class="cov8" title="1">switch v := data.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                // Extract tool name for context-aware formatting
                toolName := ""
                if tool, ok := v["tool"].(string); ok </span><span class="cov8" title="1">{
                        toolName = tool
                }</span>
                <span class="cov8" title="1">if ctx != nil </span><span class="cov0" title="0">{
                        if tool, ok := ctx["tool"].(string); ok </span><span class="cov0" title="0">{
                                toolName = tool
                        }</span>
                }

                <span class="cov8" title="1">for key, value := range v </span><span class="cov8" title="1">{
                        // Skip metadata and context fields
                        if key == "context" || key == "metadata" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">switch val := value.(type) </span>{
                        case map[string]interface{}:<span class="cov0" title="0">
                                fmt.Fprintf(w, "%s- **%s**:\n", indent, key)
                                // Pass context down for nested formatting
                                newCtx := map[string]interface{}{"tool": toolName}
                                if err := formatMarkdownPayloadWithContext(w, val, depth+1, newCtx); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case []interface{}:<span class="cov8" title="1">
                                fmt.Fprintf(w, "%s- **%s**:\n", indent, key)
                                if err := formatMarkdownPayloadWithContext(w, val, depth+1, ctx); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case string:<span class="cov8" title="1">
                                if val == "" </span><span class="cov8" title="1">{
                                        fmt.Fprintf(w, "%s- **%s**: *(empty)*\n", indent, key)
                                }</span> else<span class="cov8" title="1"> {
                                        // Smart truncation based on field and tool type
                                        truncateLimit := getTruncateLimit(key, toolName)
                                        if truncateLimit == -1 </span><span class="cov8" title="1">{
                                                // Never truncate
                                                fmt.Fprintf(w, "%s- **%s**: `%s`\n", indent, key, val)
                                        }</span> else<span class="cov8" title="1"> if len(val) &gt; truncateLimit </span><span class="cov8" title="1">{
                                                fmt.Fprintf(w, "%s- **%s**: `%s...` *(%d chars)*\n", indent, key, val[:truncateLimit], len(val))
                                        }</span> else<span class="cov8" title="1"> {
                                                fmt.Fprintf(w, "%s- **%s**: `%s`\n", indent, key, val)
                                        }</span>
                                }
                        case nil:<span class="cov8" title="1">
                                fmt.Fprintf(w, "%s- **%s**: `null`\n", indent, key)</span>
                        default:<span class="cov0" title="0">
                                fmt.Fprintf(w, "%s- **%s**: `%v`\n", indent, key, val)</span>
                        }
                }
        case []interface{}:<span class="cov8" title="1">
                for i, item := range v </span><span class="cov8" title="1">{
                        switch val := item.(type) </span>{
                        case map[string]interface{}:<span class="cov8" title="1">
                                fmt.Fprintf(w, "%s%d.\n", indent, i+1)
                                if err := formatMarkdownPayloadWithContext(w, val, depth+1, ctx); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        case []interface{}:<span class="cov0" title="0">
                                fmt.Fprintf(w, "%s%d.\n", indent, i+1)
                                if err := formatMarkdownPayloadWithContext(w, val, depth+1, ctx); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        default:<span class="cov8" title="1">
                                fmt.Fprintf(w, "%s- `%v`\n", indent, val)</span>
                        }
                }
        default:<span class="cov0" title="0">
                fmt.Fprintf(w, "%s`%v`\n", indent, v)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getTruncateLimit returns the truncation limit for a field based on its name and tool type
// Returns -1 to never truncate, or a positive number for the character limit
func getTruncateLimit(fieldName, toolName string) int <span class="cov8" title="1">{
        // Never truncate message fields
        if fieldName == "message" </span><span class="cov8" title="1">{
                return -1
        }</span>

        // For file content in Write/Edit tools, use very short limit
        <span class="cov8" title="1">isFileContentField := fieldName == "content" || fieldName == "new_string" || fieldName == "old_string" || fieldName == "new_source"
        isWriteTool := toolName == "Write" || toolName == "Edit" || toolName == "NotebookEdit"

        if isFileContentField &amp;&amp; isWriteTool </span><span class="cov8" title="1">{
                return 100 // Very short for file contents
        }</span>

        // For other long text fields, use moderate limit
        <span class="cov8" title="1">if isFileContentField || fieldName == "file_path" || fieldName == "path" </span><span class="cov8" title="1">{
                return 150
        }</span>

        // Default limit for all other fields
        <span class="cov8" title="1">return 200</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package app

import (
        "context"
        "fmt"
        "io"
        "strings"

        "github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// LogsServiceInterface defines the interface for logs operations
type LogsServiceInterface interface {
        ListRecentLogs(ctx context.Context, limit, sessionLimit int, sessionID string, ordered bool) ([]*LogRecord, error)
        ExecuteRawQuery(ctx context.Context, query string) (*pluginsdk.QueryResult, error)
}

// LogsCommandHandler handles the logs command presentation logic
type LogsCommandHandler struct {
        service LogsServiceInterface
        out     io.Writer
}

// NewLogsCommandHandler creates a new logs command handler
func NewLogsCommandHandler(service LogsServiceInterface, out io.Writer) *LogsCommandHandler <span class="cov8" title="1">{
        return &amp;LogsCommandHandler{
                service: service,
                out:     out,
        }
}</span>

// ListLogs displays logs based on the provided options
func (h *LogsCommandHandler) ListLogs(ctx context.Context, limit, sessionLimit int, sessionID string, ordered bool, format string) error <span class="cov8" title="1">{
        records, err := h.service.ListRecentLogs(ctx, limit, sessionLimit, sessionID, ordered)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(records) == 0 </span><span class="cov8" title="1">{
                fmt.Fprintln(h.out, "No logs found.")
                fmt.Fprintln(h.out, "Run 'dw init' or a plugin's init command to initialize logging.")
                return nil
        }</span>

        // Handle CSV format
        <span class="cov8" title="1">if format == "csv" </span><span class="cov8" title="1">{
                return FormatLogsAsCSV(h.out, records)
        }</span>

        // Handle Markdown format
        <span class="cov8" title="1">if format == "markdown" </span><span class="cov8" title="1">{
                return FormatLogsAsMarkdown(h.out, records)
        }</span>

        // Validate format
        <span class="cov8" title="1">if format != "text" &amp;&amp; format != "" </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid format '%s'. Valid formats: text, csv, markdown", format)
        }</span>

        // Display logs in text format
        <span class="cov8" title="1">if sessionID != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(h.out, "Showing %d logs for session %s:\n\n", len(records), sessionID)
        }</span> else<span class="cov8" title="1"> if sessionLimit &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(h.out, "Showing %d logs from %d most recent sessions:\n\n", len(records), sessionLimit)
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(h.out, "Showing %d most recent logs:\n\n", len(records))
        }</span>

        <span class="cov8" title="1">for i, record := range records </span><span class="cov8" title="1">{
                fmt.Fprint(h.out, FormatLogRecord(i, record))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ExecuteRawQuery executes a raw SQL query and displays the results
func (h *LogsCommandHandler) ExecuteRawQuery(ctx context.Context, query string) error <span class="cov8" title="1">{
        result, err := h.service.ExecuteRawQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Print column headers
        <span class="cov8" title="1">for i, col := range result.Columns </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        fmt.Fprint(h.out, " | ")
                }</span>
                <span class="cov8" title="1">fmt.Fprint(h.out, col)</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(h.out)
        fmt.Fprintln(h.out, repeatString("-", 80))

        // Print rows
        for _, row := range result.Rows </span><span class="cov8" title="1">{
                for i, val := range row </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Fprint(h.out, " | ")
                        }</span>
                        <span class="cov8" title="1">fmt.Fprint(h.out, FormatQueryValue(val))</span>
                }
                <span class="cov8" title="1">fmt.Fprintln(h.out)</span>
        }

        <span class="cov8" title="1">fmt.Fprintln(h.out)
        fmt.Fprintf(h.out, "(%d rows)\n", len(result.Rows))
        return nil</span>
}

func repeatString(s string, count int) string <span class="cov8" title="1">{
        return strings.Repeat(s, count)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package app

import (
        "context"
        "fmt"
        "io"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
        "github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// ProjectContext provides access to app-layer services for plugin tools.
// This is the internal context used by the tool registry (not SDK).
// Renamed from PluginContext to avoid confusion with SDK PluginContext.
type ProjectContext struct {
        // EventRepo provides access to logged events
        EventRepo domain.EventRepository

        // AnalysisRepo provides access to session analyses
        AnalysisRepo domain.AnalysisRepository

        // Config is the project's configuration
        Config *domain.Config

        // CWD is the current working directory
        CWD string

        // DBPath is the path to the database
        DBPath string
}

// pluginContextAdapter adapts internal services to SDK PluginContext interface.
// This allows plugins to access system capabilities without depending on internal types.
type pluginContextAdapter struct {
        logger     Logger
        dbPath     string
        workingDir string
        eventRepo  domain.EventRepository
}

// NewPluginContext creates a new plugin context adapter
func NewPluginContext(logger Logger, dbPath, workingDir string, eventRepo domain.EventRepository) pluginsdk.PluginContext <span class="cov8" title="1">{
        return &amp;pluginContextAdapter{
                logger:     logger,
                dbPath:     dbPath,
                workingDir: workingDir,
                eventRepo:  eventRepo,
        }
}</span>

func (p *pluginContextAdapter) GetLogger() pluginsdk.Logger <span class="cov8" title="1">{
        return &amp;loggerAdapter{inner: p.logger}
}</span>

func (p *pluginContextAdapter) GetWorkingDir() string <span class="cov8" title="1">{
        return p.workingDir
}</span>

func (p *pluginContextAdapter) EmitEvent(ctx context.Context, event pluginsdk.Event) error <span class="cov8" title="1">{
        // Convert SDK event to domain event
        // SDK Event has: Type, Source, Timestamp, Payload (map[string]interface{}), Metadata (map[string]string), Version (string)
        // Domain Event has: ID, Timestamp, Type (string), SessionID, Payload (interface{}), Content (string), Version (string)

        // Extract session ID from metadata if present
        sessionID := ""
        if event.Metadata != nil </span><span class="cov8" title="1">{
                sessionID = event.Metadata["session_id"]
        }</span>

        // Use the event.Type directly as it's already in dot notation
        <span class="cov8" title="1">eventType := event.Type

        // Build payload that includes both the event payload and source information
        payload := map[string]interface{}{
                "source": event.Source,
                "data":   event.Payload,
        }
        if event.Metadata != nil </span><span class="cov8" title="1">{
                payload["metadata"] = event.Metadata
        }</span>

        // Create normalized content for full-text search
        // Combine type, source, and payload fields
        <span class="cov8" title="1">contentParts := []string{eventType, event.Source}
        for _, v := range event.Payload </span><span class="cov8" title="1">{
                contentParts = append(contentParts, fmt.Sprintf("%v", v))
        }</span>
        <span class="cov8" title="1">content := fmt.Sprintf("%s", contentParts)

        // Create domain event
        domainEvent := domain.NewEvent(eventType, sessionID, payload, content)

        // Set version from SDK event, default to "1.0" if empty
        if event.Version != "" </span><span class="cov8" title="1">{
                domainEvent.Version = event.Version
        }</span> else<span class="cov8" title="1"> {
                domainEvent.Version = "1.0"
        }</span>

        // Save to repository
        <span class="cov8" title="1">if err := p.eventRepo.Save(ctx, domainEvent); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to save event: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// loggerAdapter adapts app.Logger to domain.Logger
type loggerAdapter struct {
        inner Logger
}

func (l *loggerAdapter) Debug(format string, args ...interface{}) <span class="cov8" title="1">{
        l.inner.Debug(format, args...)
}</span>

func (l *loggerAdapter) Info(format string, args ...interface{}) <span class="cov8" title="1">{
        l.inner.Info(format, args...)
}</span>

func (l *loggerAdapter) Warn(format string, args ...interface{}) <span class="cov8" title="1">{
        l.inner.Warn(format, args...)
}</span>

func (l *loggerAdapter) Error(format string, args ...interface{}) <span class="cov8" title="1">{
        l.inner.Error(format, args...)
}</span>

// commandContextAdapter adapts internal services to SDK CommandContext interface
type commandContextAdapter struct {
        pluginContextAdapter
        output io.Writer
        input  io.Reader
}

// NewCommandContext creates a new command context adapter
func NewCommandContext(logger Logger, dbPath, workingDir string, eventRepo interface{}, output io.Writer, input io.Reader) pluginsdk.CommandContext <span class="cov8" title="1">{
        return &amp;commandContextAdapter{
                pluginContextAdapter: pluginContextAdapter{
                        logger:     logger,
                        dbPath:     dbPath,
                        workingDir: workingDir,
                        eventRepo:  eventRepo.(domain.EventRepository),
                },
                output: output,
                input:  input,
        }
}</span>

func (c *commandContextAdapter) GetStdout() io.Writer <span class="cov8" title="1">{
        return c.output
}</span>

func (c *commandContextAdapter) GetStdin() io.Reader <span class="cov8" title="1">{
        return c.input
}</span>

// Note: ToolContext removed - tools now use regular context
// Tools are executed via the Tool interface which receives context.Context and args
</pre>
		
		<pre class="file" id="file10" style="display: none">package app

import (
        "context"
        "fmt"
        "sync"

        "github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// PluginRegistry manages all registered plugins and routes operations to them.
// It uses SDK plugin interfaces directly.
// Routing is capability-based: plugins declare capabilities, registry routes accordingly.
type PluginRegistry struct {
        plugins          map[string]pluginsdk.Plugin            // key: plugin name (uses SDK interface)
        entityProviders  map[string]pluginsdk.IEntityProvider   // key: entity type, value: provider
        commandProviders map[string]pluginsdk.ICommandProvider  // key: plugin name, value: provider
        eventEmitters    []pluginsdk.IEventEmitter
        entityUpdaters   map[string]pluginsdk.IEntityUpdater // key: entity type, value: updater
        logger           Logger
        mu               sync.RWMutex
}

// NewPluginRegistry creates a new plugin registry
func NewPluginRegistry(logger Logger) *PluginRegistry <span class="cov8" title="1">{
        return &amp;PluginRegistry{
                plugins:          make(map[string]pluginsdk.Plugin),
                entityProviders:  make(map[string]pluginsdk.IEntityProvider),
                commandProviders: make(map[string]pluginsdk.ICommandProvider),
                eventEmitters:    make([]pluginsdk.IEventEmitter, 0),
                entityUpdaters:   make(map[string]pluginsdk.IEntityUpdater),
                logger:           logger,
        }
}</span>

// RegisterPlugin registers a plugin with the system.
// Accepts plugins implementing the SDK Plugin interface.
// Returns error if plugin name already exists or entity type conflicts.
// Uses capability-based routing to map plugins to their provided capabilities.
func (r *PluginRegistry) RegisterPlugin(plugin pluginsdk.Plugin) error <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()

        info := plugin.GetInfo()

        // Check for duplicate plugin name
        if _, exists := r.plugins[info.Name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("plugin already registered: %s", info.Name)
        }</span>

        // Get plugin capabilities
        <span class="cov8" title="1">capabilities := plugin.GetCapabilities()

        // Route based on capabilities
        if contains(capabilities, "IEntityProvider") </span><span class="cov8" title="1">{
                entityProvider, ok := plugin.(pluginsdk.IEntityProvider)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("plugin %s declares IEntityProvider capability but doesn't implement it", info.Name)
                }</span>

                <span class="cov8" title="1">entityTypes := entityProvider.GetEntityTypes()
                // Check for entity type conflicts
                for _, et := range entityTypes </span><span class="cov8" title="1">{
                        if existingProvider, exists := r.entityProviders[et.Type]; exists </span><span class="cov8" title="1">{
                                existingInfo := existingProvider.(pluginsdk.Plugin).GetInfo()
                                return fmt.Errorf("entity type %s already provided by plugin %s", et.Type, existingInfo.Name)
                        }</span>
                }

                // Map entity types to provider
                <span class="cov8" title="1">for _, et := range entityTypes </span><span class="cov8" title="1">{
                        r.entityProviders[et.Type] = entityProvider
                        r.logger.Debug("  - Entity type: %s (capabilities: %v)", et.Type, et.Capabilities)
                }</span>
        }

        <span class="cov8" title="1">if contains(capabilities, "ICommandProvider") </span><span class="cov8" title="1">{
                commandProvider, ok := plugin.(pluginsdk.ICommandProvider)
                if !ok </span><span class="cov8" title="1">{
                        return fmt.Errorf("plugin %s declares ICommandProvider capability but doesn't implement it", info.Name)
                }</span>
                <span class="cov8" title="1">r.commandProviders[info.Name] = commandProvider</span>
        }

        <span class="cov8" title="1">if contains(capabilities, "IEventEmitter") </span><span class="cov8" title="1">{
                eventEmitter, ok := plugin.(pluginsdk.IEventEmitter)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("plugin %s declares IEventEmitter capability but doesn't implement it", info.Name)
                }</span>
                <span class="cov8" title="1">r.eventEmitters = append(r.eventEmitters, eventEmitter)</span>
        }

        <span class="cov8" title="1">if contains(capabilities, "IEntityUpdater") </span><span class="cov8" title="1">{
                entityUpdater, ok := plugin.(pluginsdk.IEntityUpdater)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("plugin %s declares IEntityUpdater capability but doesn't implement it", info.Name)
                }</span>

                <span class="cov8" title="1">entityTypes := entityUpdater.GetEntityTypes()
                // Map entity types to updater
                for _, et := range entityTypes </span><span class="cov8" title="1">{
                        r.entityUpdaters[et.Type] = entityUpdater
                }</span>
        }

        // Register plugin
        <span class="cov8" title="1">r.plugins[info.Name] = plugin
        r.logger.Debug("Registered plugin: %s (version %s) with capabilities: %v", info.Name, info.Version, capabilities)

        return nil</span>
}

// GetPlugin retrieves a plugin by name (returns SDK plugin)
func (r *PluginRegistry) GetPlugin(name string) (pluginsdk.Plugin, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        plugin, exists := r.plugins[name]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("plugin not found: %s", name)
        }</span>

        <span class="cov8" title="1">return plugin, nil</span>
}

// GetPluginForEntityType retrieves the plugin that provides a given entity type
func (r *PluginRegistry) GetPluginForEntityType(entityType string) (pluginsdk.Plugin, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        provider, exists := r.entityProviders[entityType]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no plugin found for entity type: %s", entityType)
        }</span>

        // IEntityProvider extends Plugin, so we can cast safely
        <span class="cov8" title="1">return provider.(pluginsdk.Plugin), nil</span>
}

// GetAllPlugins returns all registered plugins (SDK plugins)
func (r *PluginRegistry) GetAllPlugins() []pluginsdk.Plugin <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        plugins := make([]pluginsdk.Plugin, 0, len(r.plugins))
        for _, plugin := range r.plugins </span><span class="cov8" title="1">{
                plugins = append(plugins, plugin)
        }</span>

        <span class="cov8" title="1">return plugins</span>
}

// GetPluginInfos returns metadata for all registered plugins
func (r *PluginRegistry) GetPluginInfos() []pluginsdk.PluginInfo <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        infos := make([]pluginsdk.PluginInfo, 0, len(r.plugins))
        for _, plugin := range r.plugins </span><span class="cov8" title="1">{
                infos = append(infos, plugin.GetInfo())
        }</span>

        <span class="cov8" title="1">return infos</span>
}

// GetAllEntityTypes returns all entity types from all plugins
func (r *PluginRegistry) GetAllEntityTypes() []pluginsdk.EntityTypeInfo <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        var entityTypes []pluginsdk.EntityTypeInfo
        for _, plugin := range r.plugins </span><span class="cov8" title="1">{
                // Only get entity types from plugins that provide entities
                if entityProvider, ok := plugin.(pluginsdk.IEntityProvider); ok </span><span class="cov8" title="1">{
                        entityTypes = append(entityTypes, entityProvider.GetEntityTypes()...)
                }</span>
        }

        <span class="cov8" title="1">return entityTypes</span>
}

// Query executes a query across one or more plugins
func (r *PluginRegistry) Query(ctx context.Context, query pluginsdk.EntityQuery) ([]pluginsdk.IExtensible, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // If entity type is specified, route to specific provider
        if query.EntityType != "" </span><span class="cov8" title="1">{
                provider, exists := r.entityProviders[query.EntityType]
                if !exists </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no provider for entity type: %s", query.EntityType)
                }</span>

                <span class="cov8" title="1">return provider.Query(ctx, query)</span>
        }

        // Otherwise, query all entity providers and combine results
        <span class="cov8" title="1">var allEntities []pluginsdk.IExtensible
        for _, provider := range r.entityProviders </span><span class="cov8" title="1">{
                entities, err := provider.Query(ctx, query)
                if err != nil </span><span class="cov0" title="0">{
                        pluginInfo := provider.(pluginsdk.Plugin).GetInfo()
                        r.logger.Warn("Plugin %s query failed: %v", pluginInfo.Name, err)
                        continue</span>
                }

                // Append results
                <span class="cov8" title="1">allEntities = append(allEntities, entities...)</span>
        }

        <span class="cov8" title="1">return allEntities, nil</span>
}

// GetEntity retrieves a single entity by ID.
// Searches all entity providers until the entity is found.
func (r *PluginRegistry) GetEntity(ctx context.Context, entityID string) (pluginsdk.IExtensible, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Try each entity provider until we find the entity
        for _, provider := range r.entityProviders </span><span class="cov8" title="1">{
                entity, err := provider.GetEntity(ctx, entityID)
                if err == nil </span><span class="cov8" title="1">{
                        return entity, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("entity not found: %s", entityID)</span>
}

// UpdateEntity updates an entity's fields
func (r *PluginRegistry) UpdateEntity(ctx context.Context, entityID string, fields map[string]interface{}) (pluginsdk.IExtensible, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Try each entity updater until we find and update the entity
        for _, updater := range r.entityUpdaters </span><span class="cov8" title="1">{
                entity, err := updater.UpdateEntity(ctx, entityID, fields)
                if err == nil </span><span class="cov8" title="1">{
                        return entity, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("entity not found or not updatable: %s", entityID)</span>
}

// GetCommandProvider retrieves a command provider for a plugin
func (r *PluginRegistry) GetCommandProvider(pluginName string) (pluginsdk.ICommandProvider, error) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        provider, exists := r.commandProviders[pluginName]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no command provider for plugin: %s", pluginName)
        }</span>

        <span class="cov8" title="1">return provider, nil</span>
}

// GetAllCommandProviders returns all registered command providers
func (r *PluginRegistry) GetAllCommandProviders() []pluginsdk.ICommandProvider <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        providers := make([]pluginsdk.ICommandProvider, 0, len(r.commandProviders))
        for _, provider := range r.commandProviders </span><span class="cov0" title="0">{
                providers = append(providers, provider)
        }</span>

        <span class="cov8" title="1">return providers</span>
}

// GetEventEmitters returns all registered event emitters
func (r *PluginRegistry) GetEventEmitters() []pluginsdk.IEventEmitter <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        // Return a copy to avoid concurrent modification
        emitters := make([]pluginsdk.IEventEmitter, len(r.eventEmitters))
        copy(emitters, r.eventEmitters)
        return emitters
}</span>

// contains checks if a string slice contains a specific string
func contains(slice []string, item string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == item </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package app

import (
        "context"
        "fmt"
        "io"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
)

// RefreshCommandHandler handles the refresh command logic.
// This performs framework-level refresh (database schema, config).
// Plugin-specific refresh is handled by each plugin's refresh command.
type RefreshCommandHandler struct {
        repo         domain.EventRepository
        configLoader ConfigLoader
        logger       Logger
        out          io.Writer
}

// ConfigLoader interface for config loading
type ConfigLoader interface {
        LoadConfig(path string) (*domain.Config, error)
        InitializeDefaultConfig(path string) (string, error)
}

// NewRefreshCommandHandler creates a new refresh command handler
func NewRefreshCommandHandler(
        repo domain.EventRepository,
        configLoader ConfigLoader,
        logger Logger,
        out io.Writer,
) *RefreshCommandHandler <span class="cov8" title="1">{
        return &amp;RefreshCommandHandler{
                repo:         repo,
                configLoader: configLoader,
                logger:       logger,
                out:          out,
        }
}</span>

// Execute runs the framework-level refresh operation
func (h *RefreshCommandHandler) Execute(ctx context.Context, dbPath string) error <span class="cov8" title="1">{
        fmt.Fprintln(h.out, "Refreshing DarwinFlow framework...")
        fmt.Fprintln(h.out)

        // Step 1: Update database schema
        fmt.Fprintln(h.out, "Updating database schema...")
        if err := h.repo.Initialize(ctx); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error updating database schema: %w", err)
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(h.out, "âœ“ Database schema updated: %s\n", dbPath)

        // Step 2: Initialize config if needed
        fmt.Fprintln(h.out)
        fmt.Fprintln(h.out, "Checking configuration...")

        // Try to load config
        config, err := h.configLoader.LoadConfig("")
        if err != nil || config == nil </span><span class="cov8" title="1">{
                // Config doesn't exist or is invalid, create default
                fmt.Fprintln(h.out, "Creating default configuration...")
                configPath, err := h.configLoader.InitializeDefaultConfig("")
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(h.out, "Warning: Could not create default config: %v\n", err)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(h.out, "âœ“ Configuration initialized: %s\n", configPath)
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintln(h.out, "âœ“ Configuration is valid")
        }</span>

        // Done
        <span class="cov8" title="1">fmt.Fprintln(h.out)
        fmt.Fprintln(h.out, "âœ“ Framework refreshed successfully!")
        fmt.Fprintln(h.out)
        fmt.Fprintln(h.out, "Framework changes applied:")
        fmt.Fprintln(h.out, "  â€¢ Database schema updated with latest migrations")
        fmt.Fprintln(h.out, "  â€¢ Configuration verified")
        fmt.Fprintln(h.out)
        fmt.Fprintln(h.out, "Note: To refresh plugin-specific configuration, run the plugin's init command")
        fmt.Fprintln(h.out, "Example: dw &lt;plugin-name&gt; init")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package app

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/kgatilin/darwinflow-pub/internal/domain"
)

const (
        // DefaultDBPath is the default location for the event database
        DefaultDBPath = ".darwinflow/logs/events.db"
)

// SetupService orchestrates initialization of the DarwinFlow framework infrastructure.
// This is framework-level setup only (database, schema, etc.).
// Plugins handle their own initialization via their init commands.
type SetupService struct {
        repository domain.EventRepository
        logger     Logger
}

// NewSetupService creates a new setup service
func NewSetupService(
        repository domain.EventRepository,
        logger Logger,
) *SetupService <span class="cov8" title="1">{
        return &amp;SetupService{
                repository: repository,
                logger:     logger,
        }
}</span>

// Initialize sets up the framework-level infrastructure.
// This includes creating the database directory and initializing the repository schema.
// Plugin-specific initialization is handled by each plugin's init command.
func (s *SetupService) Initialize(ctx context.Context, dbPath string) error <span class="cov8" title="1">{
        // Create database directory
        dir := filepath.Dir(dbPath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create log directory: %w", err)
        }</span>

        // Initialize repository (create schema, indexes, etc.)
        <span class="cov8" title="1">if err := s.repository.Initialize(ctx); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to initialize repository: %w", err)
        }</span>

        <span class="cov8" title="1">s.logger.Info("Framework infrastructure initialized")
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
